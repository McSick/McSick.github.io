<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Fantasy Roguelite Grid Battle — Story, Boss, Loadout, FX</title>
  <style>
    :root {
      --ui-bg: rgba(20,20,28,0.85);
      --ui-text: #f0f4ff;
      --accent: #8ad1ff;
      --good: #7cf59a;
      --bad: #ff8a8a;
      --gold: #ffd76a;
      --shadow: #c18cff;
      --boss: #ff7ad6;
    }
    html, body {
      margin: 0; padding: 0; background: #0f1220; color: var(--ui-text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
      height: 100%; overflow: hidden; touch-action: none;
    }
    #gameWrap { position: relative; width: 100vw; height: 100vh; }
    canvas { display: block; width: 100%; height: 100%; background: #0a0d18; }

    /* HUD */
    .hud {
      position: absolute; left: 0; right: 0; top: 0; padding: 8px 10px;
      display: grid; grid-template-columns: 1fr auto auto; gap: 8px; align-items: center; pointer-events: none;
      background: linear-gradient(to bottom, rgba(0,0,0,0.6), rgba(0,0,0,0));
      font-weight: 600; text-shadow: 0 1px 2px #000;
    }
    .leftStack{display:flex; gap:8px; align-items:center;}
    .hud .stat { pointer-events: auto; background: var(--ui-bg); padding: 6px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.07); }
    .hud .hpBar { width: 140px; height: 12px; background: #2a2f44; border-radius: 999px; overflow: hidden; border: 1px solid #000; }
    .hud .hpFill { height: 100%; background: linear-gradient(90deg, #5fff9b, #2ee6ff); }
    .hud .gold { color: var(--gold); }
    .hud .class { color: var(--accent); }
    .hud .pages { color: var(--shadow); }
    .hud .armor { color: #ffd6a6; }
    .miniBtn { pointer-events:auto; padding:8px 12px; border-radius:12px; border:1px solid rgba(255,255,255,0.12); background:#1a1f3f; color:var(--ui-text); font-weight:800; }
    .progress { width: 200px; height: 10px; background:#283050; border-radius:999px; overflow:hidden; border:1px solid rgba(255,255,255,0.08); }
    .progressFill { height:100%; background: linear-gradient(90deg,#6fe7ff,#b58cff); }

    /* Controls */
    .controls { position: absolute; bottom: 10px; left: 10px; right: 10px; display: flex; justify-content: space-between; align-items: flex-end; gap: 10px; pointer-events: none; }
    .dpad { pointer-events: auto; width: 200px; height: 200px; position: relative; }
    .dpad button { position: absolute; width: 70px; height: 70px; border-radius: 16px; border: 1px solid rgba(255,255,255,0.15); background: var(--ui-bg); color: var(--ui-text); font-size: 18px; font-weight: 700; }
    .dpad .up { top: 0; left: 65px; }
    .dpad .down { bottom: 0; left: 65px; }
    .dpad .left { left: 0; top: 65px; }
    .dpad .right { right: 0; top: 65px; }

    .abilities { pointer-events: auto; display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; width: min(60vw, 380px); }
    .abilities button { height: 76px; border-radius: 16px; border: 1px solid rgba(255,255,255,0.15); background: var(--ui-bg); color: var(--ui-text); font-size: 13px; font-weight: 700; padding: 6px; text-align: left; }
    .abilities button.cooldown { opacity: 0.5; filter: grayscale(0.5); }

    .smallRow { display: flex; gap: 8px; align-items: center; }
    .pill { padding: 2px 6px; border-radius: 999px; background: rgba(255,255,255,0.08); font-size: 12px; border: 1px solid rgba(255,255,255,0.12); }

    /* Modal */
    .modal { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(3,6,12,0.75); backdrop-filter: blur(6px); }
    .modal.show { display: flex; }
    .card { width: min(92vw, 820px); max-height: 90vh; overflow: auto; background: #121528; border: 1px solid rgba(255,255,255,0.08); border-radius: 18px; padding: 14px; box-shadow: 0 10px 60px rgba(0,0,0,0.5); }
    .card h2 { margin: 8px 0 12px; }
    .choices { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; }
    .choice { background: #0f1328; border: 1px solid rgba(255,255,255,0.08); border-radius: 14px; padding: 10px; }
    .choice .title { font-weight: 800; margin-bottom: 6px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .choice button { margin-top: 8px; width: 100%; padding: 8px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12); background: #1a1f3f; color: var(--ui-text); font-weight: 800; }

    .footerRow { margin-top: 10px; display: flex; justify-content: space-between; align-items: center; gap: 8px; }
    .footerRow button { padding: 10px 14px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.12); background: #1a1f3f; color: var(--ui-text); font-weight: 800; }
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="game"></canvas>

    <!-- HUD -->
    <div class="hud">
      <div class="leftStack">
        <div class="stat">Room: <span id="roomType">-</span></div>
        <div class="stat smallRow">
          <span>HP</span>
          <div class="hpBar"><div id="hpFill" class="hpFill" style="width:100%"></div></div>
        </div>
        <div class="stat">Gold: <span id="gold" class="gold">0</span></div>
        <div class="stat">Class: <span id="clazz" class="class">-</span></div>
        <div class="stat">Pages: <span id="pages" class="pages">0</span></div>
        <div class="stat">Armor: <span id="armorName" class="armor">None</span></div>
        <div class="stat smallRow">
          <span>Stage:</span>
          <div class="progress"><div id="stageProg" class="progressFill" style="width:0%"></div></div>
          <span id="stageLabel" style="opacity:.8"></span>
        </div>
      </div>
      <div class="stat" style="pointer-events:auto">
        <button id="loadoutBtn" class="miniBtn">☰ Loadout</button>
      </div>
      <div class="stat" style="pointer-events:auto">
        <button id="restartBtn" class="miniBtn">↻ Restart</button>
      </div>
    </div>

    <!-- Controls -->
    <div class="controls">
      <div class="dpad">
        <button class="up" data-dir="up">▲</button>
        <button class="down" data-dir="down">▼</button>
        <button class="left" data-dir="left">◀</button>
        <button class="right" data-dir="right">▶</button>
      </div>
      <div class="abilities" id="abilities"></div>
    </div>

    <!-- Modal for class select/loot/shop/story/heal/boss/loadout/gameover -->
    <div class="modal" id="modal">
      <div class="card" id="modalCard">
        <h2 id="modalTitle">Loot!</h2>
        <div id="modalContent"></div>
        <div class="footerRow" id="modalFooter"></div>
      </div>
    </div>
  </div>

<script>
(function(){
  // ===================== Utilities =====================
  const rand = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;
  const choice = arr => arr[Math.floor(Math.random()*arr.length)];
  const clamp = (v,mi,ma)=> Math.max(mi, Math.min(ma, v));

  // ===================== Canvas Setup =====================
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function resize(){ canvas.width = Math.floor(window.innerWidth*DPR); canvas.height = Math.floor(window.innerHeight*DPR); canvas.style.width = '100%'; canvas.style.height = '100%'; }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ===================== Grid Config =====================
  const GRID_W = 8, GRID_H = 6, TILE = Math.floor(Math.min(canvas.width/(GRID_W+2), canvas.height/(GRID_H+4)));
  const gridOffsetX = Math.floor((canvas.width - GRID_W*TILE)/2);
  const gridOffsetY = Math.floor((canvas.height - GRID_H*TILE)/2);

  // ===================== Sprites =====================
  const SPRITES = {
    floor: 'https://raw.githubusercontent.com/kenneyNL/roguelikeDungeon_transparent/master/Spritesheet/roguelikeDungeon_transparent.png',
    hero: 'https://raw.githubusercontent.com/kenneyNL/pixel-character-pack/master/PNG/Default/p1_stand.png',
    slime: 'https://raw.githubusercontent.com/kenneyNL/tiny-dungeon/master/Tiles/tile_0018.png'
  };
  const images = {};
  const loadImage = (key, src) => new Promise(res=>{ const img = new Image(); img.crossOrigin='anonymous'; img.onload=()=>{ images[key]=img; res(); }; img.onerror=()=>{ images[key]=null; res(); }; img.src=src; });
  Promise.all(Object.entries(SPRITES).map(([k,src])=>loadImage(k,src)));

  // ===================== Effects, FX & Combos =====================
  const EFFECTS = { BURN:'Burn', FREEZE:'Freeze', SHOCK:'Shock', POISON:'Poison', BLEED:'Bleed', STUN:'Stun', STEALTH:'Stealth', HASTE:'Haste' };

  const FX = { floaters: [], hitFlash:0, shake:0, toasts:[], stealthPulse:0 };
  function addFloatText(gx, gy, text, color='#fff', life=60){
    const x = gridOffsetX + gx*TILE + TILE/2 + rand(-6,6);
    const y = gridOffsetY + gy*TILE + TILE/2 + rand(-2,2);
    FX.floaters.push({x,y,vy:-0.6,life,ttl:life,text,color,scale:1});
  }
  function addToast(text, color='#fff', time=120){ FX.toasts.push({text,color,time}); }
  function screenShake(str=6){ FX.shake = Math.max(FX.shake, str); }

  function addEffect(entity, type, duration=1, power=0){
    if(!entity.effects) entity.effects = [];
    const e = entity.effects.find(e=>e.type===type);
    if(e){ e.duration = Math.max(e.duration, duration); e.power = Math.max(e.power, power); }
    else entity.effects.push({type, duration, power});
  }
  function hasEffect(entity, type){ return entity.effects && entity.effects.some(e=>e.type===type && e.duration>0); }
  function consumeEffect(entity, type){ if(!entity.effects) return; const i=entity.effects.findIndex(e=>e.type===type && e.duration>0); if(i>=0) entity.effects.splice(i,1); }

  // Tick effects at the start of the subject's turn; return {skip}
  function processEffects(entity){
    if(!entity.effects) return {skip:false};
    let skip=false; const out = [];
    for(const eff of entity.effects){
      switch(eff.type){
        case EFFECTS.BURN:
          entity.hp -= eff.power||4; eff.duration--; addFloatText(entity.x, entity.y, `-${eff.power||4}🔥`, '#ffb0a0', 40); break;
        case EFFECTS.POISON:
          entity.hp -= eff.power||5; eff.duration--; addFloatText(entity.x, entity.y, `-${eff.power||5}☠`, '#9cff9c', 40); break;
        case EFFECTS.SHOCK:
          eff.duration--; break;
        case EFFECTS.FREEZE:
          eff.duration--; skip = true; break;
        case EFFECTS.STUN:
          eff.duration--; skip = true; break;
        case EFFECTS.STEALTH:
          eff.duration--; break;
        case EFFECTS.HASTE:
          eff.duration--; break;
      }
      if(eff.duration>0) out.push(eff);
    }
    entity.effects = out;
    return {skip};
  }

  // Combo helpers executed on hit
  function onHitCombos(attacker, target, baseDamage, meta){
    let dmg = baseDamage;
    // Shatter
    if(hasEffect(target, EFFECTS.FREEZE)){
      dmg = Math.round(dmg * 1.5); consumeEffect(target, EFFECTS.FREEZE);
      if(Math.random()<0.25) addEffect(target, EFFECTS.STUN, 1);
      addFloatText(target.x, target.y, 'SHATTER!', '#bde0ff', 40);
    }
    // Overload
    if(meta.element==='Shock' && hasEffect(target, EFFECTS.BURN)){
      splashDamage(target.x, target.y, 10); addFloatText(target.x, target.y, 'OVERLOAD', '#ffe477', 40);
    }
    // Backstab
    if(hasEffect(attacker, EFFECTS.STEALTH)){
      dmg = Math.round(dmg * 1.5);
      if(State.player===attacker){ State.player.pages++; }
      consumeEffect(attacker, EFFECTS.STEALTH);
      State.extraActions++; addFloatText(attacker.x, attacker.y, 'BACKSTAB!', '#d6b8ff', 45);
    }
    return dmg;
  }

  function splashDamage(cx, cy, amount){
    for(const e of State.enemies){ if(Math.abs(e.x-cx)+Math.abs(e.y-cy)===1){ e.hp -= amount; addFloatText(e.x, e.y, `-${amount}`, '#ffd18a', 40); } }
  }

  // ===================== Story / Stages =====================
  const STAGES = [
    {
      name: 'Crypt of Cinders', floors: 4,
      story: [
        'You descend into the ember-lit crypt. Ash whispers of a stolen flame.',
        'Charred runes hint at a Warden siphoning life from below.',
        'A survivor speaks: “Break the Warden’s brazier and the dead will rest.”',
        'The air glows. The brazier is near. Prepare yourself.'
      ],
      boss: { name:'Ember Warden', theme:'Flaming', hp: 220, dmg: 18 }
    }
  ];

  // ===================== Game State =====================
  const State = {
    roomType: 'BATTLE', gold: 0,
    player: { x:1, y:1, hp:100, maxHp:100, abilities:[], shields:0, effects:[], pages:0, class:'-', armor:null, armorMods:{}, talents:{} },
    enemies: [], turn: 'PLAYER', selection: null,
    floor: 1, stage: 0, stageFloor: 1, storyIndex: 0,
    extraActions: 0,
  };

  // ===================== Classes & Talents =====================
  const CLASSES = {
    Wizard: {
      desc: 'Spells +1 range. Elements last longer.',
      onMakeAbility: (ab)=>{ if(ab.type==='attack') ab.range = Math.min(4, (ab.range||1)+1); },
      talents: [
        {key:'ArcaneBattery', label:'Arcane Battery — every 3rd spell refunds cooldown', apply:(p)=>p.talents.ArcaneBattery=true},
        {key:'Glacier', label:'Glacier — Freeze lasts +1', apply:(p)=>p.talents.Glacier=true},
        {key:'Conduction', label:'Conduction — Shocked enemies take +25% dmg', apply:(p)=>p.talents.Conduction=true},
      ]
    },
    Rogue: {
      desc: 'End turn away from enemies to gain Stealth. Attacking from Stealth grants a Page.',
      passiveEndTurn: ()=>{
        const adj = State.enemies.some(e=>Math.abs(e.x-State.player.x)+Math.abs(e.y-State.player.y)===1);
        if(!adj){ addEffect(State.player, EFFECTS.STEALTH, 1 + (State.player.armorMods?.stealthPlus||0)); addFloatText(State.player.x, State.player.y, 'STEALTH', '#9ad5ff', 45); }
      },
      talents: [
        {key:'Flurry', label:'Flurry — First attack each battle hits twice', apply:(p)=>p.talents.Flurry=true},
        {key:'ShadowScholar', label:'Shadow Scholar — End turns in Stealth: +1 Page', apply:(p)=>p.talents.ShadowScholar=true},
        {key:'Expose', label:'Expose — Bleeding enemies take +30% dmg', apply:(p)=>p.talents.Expose=true},
      ]
    },
    Fighter: {
      desc: '+20 max HP. On kill gain Haste (extra action).',
      onStart:(p)=>{ p.maxHp+=20; p.hp=p.maxHp; },
      passiveOnKill: ()=>{ State.extraActions++; addFloatText(State.player.x, State.player.y, 'HASTE!', '#aef5a9', 50); },
      talents: [
        {key:'Riposte', label:'Riposte — 25% to counter 6 dmg when hit', apply:(p)=>p.talents.Riposte=true},
        {key:'BrutalStrikes', label:'Brutal Strikes — +20% attack dmg', apply:(p)=>p.talents.BrutalStrikes=true},
        {key:'Bulwark', label:'Bulwark — Start each battle with 15 Shield', apply:(p)=>p.talents.Bulwark=true},
      ]
    },
    Cleric: {
      desc: 'Heals grant 50% as Shield and cleanse 1 debuff.',
      passiveOnHeal: (amt)=>{ State.player.shields += Math.floor(amt*0.5); cleanseOne(State.player); addFloatText(State.player.x, State.player.y, '+Shield', '#c9ffe5', 40); },
      talents: [
        {key:'Sanctify', label:'Sanctify — Heals +20%; purge enemy buffs', apply:(p)=>p.talents.Sanctify=true},
        {key:'Aegis', label:'Aegis — Begin each floor with 10 Shield', apply:(p)=>p.talents.Aegis=true},
        {key:'Mercy', label:'Mercy — 20% at turn start: -1 to all CDs', apply:(p)=>p.talents.Mercy=true},
      ]
    }
  };

  function cleanseOne(entity){ if(!entity.effects) return; const bad=[EFFECTS.BURN,EFFECTS.POISON,EFFECTS.BLEED,EFFECTS.SHOCK,EFFECTS.FREEZE,EFFECTS.STUN]; const i=entity.effects.findIndex(e=>bad.includes(e.type)); if(i>=0) entity.effects.splice(i,1); }

  // ===================== Ability Factory =====================
  const RARITY = [
    {key:'Common', color:'#c8d0e0', weight: 40, mult: 1},
    {key:'Uncommon', color:'#7cf59a', weight: 30, mult: 1.2},
    {key:'Rare', color:'#8ad1ff', weight: 18, mult: 1.45},
    {key:'Epic', color:'#b189ff', weight: 9, mult: 1.8},
    {key:'Legendary', color:'#ffbf4f', weight: 3, mult: 2.3},
  ];
  function weightedPick(){ const total = RARITY.reduce((a,r)=>a+r.weight,0); let r = Math.random()*total; for(const it of RARITY){ if((r-=it.weight)<=0) return it; } return RARITY[0]; }
  const PREFIX = ['Rusty','Fine','Cruel','Heroic','Mystic','Ancient','Gilded','Doomed','Serrated','Blessed'];
  const ELEMENT = ['', 'Flaming','Frost','Shock','Venom','Holy','Shadow'];
  const BASE = [
    {key:'Slash', type:'attack'}, {key:'Bolt', type:'attack'}, {key:'Blast', type:'attack'}, {key:'Stab', type:'attack'},
    {key:'Heal', type:'heal'}, {key:'Shield', type:'shield'}, {key:'Blink', type:'move'}, {key:'Hide', type:'stealth'},
    {key:'Tome', type:'tome'}
  ];

  function makeAbility(){
    const rar = weightedPick();
    const pre = choice(PREFIX);
    const ele = choice(ELEMENT);
    const base = choice(BASE);
    const mult = rar.mult;

    let dmg=0, heal=0, shield=0, range=1, cd=0, desc='', hits=1, type=base.type, element=null;

    if(type==='attack'){
      dmg = Math.round(choice([7,9,11,13,15])*mult);
      range = choice([1,2,3]);
      cd = choice([0,1,2]);
      hits = Math.random()<0.15?2:1;
      element = ele||null;
      desc = `Deal ${dmg}${hits>1?` x${hits}`:''} at range ${range}${element?` (${element})`:''}.`;
    } else if(type==='heal'){
      heal = Math.round(choice([10,14,18,22])*mult);
      cd = choice([1,2]);
      desc = `Restore ${heal} HP. (Cleric: Shield & cleanse)`;
    } else if(type==='shield'){
      shield = Math.round(choice([8,12,16,20])*mult);
      cd = choice([2,3]);
      desc = `Gain ${shield} Shield for 1 room.`;
    } else if(type==='move'){
      range = choice([2,3]);
      cd = choice([1,2]);
      desc = `Teleport within ${range} tiles.`;
    } else if(type==='stealth'){
      cd = 2; range = 0; desc = `Enter Stealth for 1 turn.`;
    } else if(type==='tome'){
      cd = 1; range = 0; desc = `Spend up to 2 Pages: +1 hit to next attack per Page.`;
    }

    const name = [pre, ele, base.key].filter(Boolean).join(' ');
    const ab = { name, rarity: rar.key, color: rar.color, type, dmg, heal, shield, range, cd, cdLeft: 0, desc, hits, element };
    const c = State.player.class && CLASSES[State.player.class];
    if(c && c.onMakeAbility) c.onMakeAbility(ab);
    return ab;
  }

  function newAbilitySet(){ const arr=[]; while(arr.length<4) arr.push(makeAbility()); return arr; }

  // ===================== Armor =====================
  const ARMOR_POOL = [
    {name:'Leather of Shadows', desc:'+1 Stealth duration; attacks from Stealth +10%.', apply:(p)=>{ p.armorMods={stealthPlus:1, stealthDmg:1.10}; }},
    {name:'Frostplate', desc:'Attacks inflict brief Freeze (1).', apply:(p)=>{ p.armorMods={onHitFreeze:1}; }},
    {name:'Storm Mail', desc:'Shock duration +1; Overload splash +5 dmg.', apply:(p)=>{ p.armorMods={shockPlus:1, overloadPlus:5}; }},
    {name:'Pyromancer Robe', desc:'Burn ticks +2.', apply:(p)=>{ p.armorMods={burnPlus:2}; }},
    {name:"Knight's Bulwark", desc:'Start battle with +15 Shield.', apply:(p)=>{ p.armorMods={startShield:15}; }}
  ];

  function equipArmor(armor){ State.player.armor = armor; armor.apply(State.player); updateHUD(); addToast(`Equipped: ${armor.name}`, '#ffd6a6'); }

  // ===================== Enemies =====================
  function spawnEnemies(){
    const count = clamp(1 + Math.floor(State.floor/2), 1, 4);
    const enemies = [];
    for(let i=0;i<count;i++){
      enemies.push({ x: GRID_W-2-i, y: GRID_H-2, hp: 30 + 12*State.floor, dmg: 8 + 2*State.floor, effects:[] });
    }
    return enemies;
  }
  function spawnBoss(){
    const stage = STAGES[State.stage];
    const b = stage.boss;
    const boss = { x: GRID_W-3, y: Math.floor(GRID_H/2), hp: b.hp, dmg: b.dmg, effects:[], isBoss:true, name:b.name, theme:b.theme };
    return [boss];
  }

  // ===================== Room Flow =====================
  const RoomTypes = ['BATTLE','STORY','SHOP','HEAL','BOSS'];
  function nextRoom(){
    State.selection = null; State.turn='PLAYER'; State.extraActions=0;

    const stage = STAGES[State.stage];
    const isBossNow = (State.stageFloor>stage.floors);
    if(isBossNow){
      State.roomType = 'BOSS'; State.enemies = spawnBoss();
      addToast(`Boss: ${stage.boss.name}`, 'var(--boss)', 180);
    } else {
      const weights = {BATTLE: 55, STORY: 15, SHOP: 15, HEAL: 15};
      const pool = []; for(const k of ['BATTLE','STORY','SHOP','HEAL']) for(let i=0;i<weights[k];i++) pool.push(k);
      State.roomType = choice(pool);
      if(State.roomType==='BATTLE'){ State.player.x=1; State.player.y=Math.floor(GRID_H/2); State.enemies=spawnEnemies(); }
      else { State.enemies=[]; openRoomModal(); }
    }

    // Armor/talents battle-start passives
    if(State.roomType==='BATTLE' || State.roomType==='BOSS'){
      if(State.player.armorMods && State.player.armorMods.startShield) State.player.shields += State.player.armorMods.startShield;
      if(State.player.class==='Cleric' && State.player.talents.Aegis) State.player.shields += 10;
    }

    updateHUD();
  }

  function updateHUD(){
    const stage = STAGES[State.stage];
    document.getElementById('roomType').textContent = State.roomType + ` (F${State.floor})`;
    document.getElementById('gold').textContent = State.gold;
    document.getElementById('clazz').textContent = State.player.class;
    document.getElementById('pages').textContent = State.player.pages;
    document.getElementById('armorName').textContent = State.player.armor? State.player.armor.name : 'None';
    const pct = Math.round((State.player.hp/State.player.maxHp)*100);
    document.getElementById('hpFill').style.width = clamp(pct,0,100) + '%';
    const progress = Math.min(100, Math.floor((Math.min(State.stageFloor, stage.floors)/stage.floors)*100));
    document.getElementById('stageProg').style.width = progress+'%';
    document.getElementById('stageLabel').textContent = `${stage.name} ${Math.min(State.stageFloor,stage.floors)}/${stage.floors}`;
  }

  // ===================== Modal Logic =====================
  const modal = document.getElementById('modal');
  const modalTitle = document.getElementById('modalTitle');
  const modalContent = document.getElementById('modalContent');
  const modalFooter = document.getElementById('modalFooter');
  function showModal(){ modal.classList.add('show'); }
  function hideModal(){ modal.classList.remove('show'); modalContent.innerHTML=''; modalFooter.innerHTML=''; }

  function openLoadoutModal(){
    modalTitle.textContent = 'Loadout'; modalContent.innerHTML=''; modalFooter.innerHTML='';
    const wrap = document.createElement('div');
    const section = (title, el)=>{ const h=document.createElement('h3'); h.textContent=title; wrap.appendChild(h); wrap.appendChild(el); };

    // Class
    const c = document.createElement('div'); c.className='choice';
    c.innerHTML = `<div class="title">Class</div><div class="row">${State.player.class} — ${CLASSES[State.player.class]?.desc||''}</div>`;
    // Armor
    const a = document.createElement('div'); a.className='choice';
    a.innerHTML = `<div class="title">Armor</div><div class="row">${State.player.armor?`<b>${State.player.armor.name}</b> — ${State.player.armor.desc}`:'None'}</div>`;
    // Talents
    const tWrap = document.createElement('div'); tWrap.className='choices';
    const learned = Object.entries(State.player.talents).filter(([k,v])=>v);
    if(learned.length===0){ const d=document.createElement('div'); d.className='choice'; d.innerHTML='<div class="row">No talents learned yet.</div>'; tWrap.appendChild(d); }
    else {
      learned.forEach(([key])=>{
        const def = CLASSES[State.player.class]?.talents.find(t=>t.key===key);
        const d=document.createElement('div'); d.className='choice'; d.innerHTML=`<div class='title'>${def?.label||key}</div>`; tWrap.appendChild(d);
      });
    }
    section('Class', c); section('Armor', a); section('Talents', tWrap);
    modalContent.appendChild(wrap);
    const close = document.createElement('button'); close.textContent='Close'; close.onclick=()=>hideModal(); modalFooter.appendChild(close);
    showModal();
  }

  function openRoomModal(){
    modalTitle.textContent = State.roomType; modalContent.innerHTML=''; modalFooter.innerHTML='';

    if(State.roomType==='STORY'){
      const stage = STAGES[State.stage];
      const line = stage.story[Math.min(State.storyIndex, stage.story.length-1)];
      modalContent.innerHTML = `<p>${line}</p>`;
      const cont = document.createElement('button'); cont.textContent = 'Continue'; cont.onclick=()=>{ State.storyIndex++; hideModal(); nextRoom(); };
      modalFooter.appendChild(cont); showModal();
    }
    else if(State.roomType==='SHOP'){
      const offers = [makeAbility(), makeAbility(), makeAbility()];
      const prices = offers.map(()=> rand(25,50));
      const wrap = document.createElement('div'); wrap.className='choices';
      offers.forEach((ab,i)=>{
        const div = document.createElement('div'); div.className='choice';
        div.innerHTML = `<div class="title" style="color:${ab.color}">${ab.name} <span class="pill">${ab.rarity}</span></div>
          <div class="row"><span>${ab.desc}</span></div>
          <div class="row"><span class="pill">CD ${ab.cd}</span><span class="pill">Range ${ab.range||1}</span>${ab.hits>1?`<span class="pill">Hits ${ab.hits}</span>`:''}</div>
          <div class="row" style="margin-top:6px">Price: <b class="gold">${prices[i]}g</b></div>`;
        const buy = document.createElement('button'); buy.textContent='Buy & replace...'; buy.onclick=()=> replaceAbilityFlow(ab, prices[i]);
        div.appendChild(buy); wrap.appendChild(div);
      });
      // Armor
      const armor = choice(ARMOR_POOL);
      const armorDiv = document.createElement('div'); armorDiv.className='choice';
      armorDiv.innerHTML = `<div class="title">${armor.name}</div><div class="row">${armor.desc}</div><div class='row' style='margin-top:6px'>Price: <b class='gold'>60g</b></div>`;
      const buyA = document.createElement('button'); buyA.textContent='Buy armor'; buyA.onclick=()=>{ if(State.gold<60){ buyA.textContent='Not enough gold'; return; } State.gold-=60; equipArmor(armor); updateHUD(); hideModal(); nextRoom(); };
      armorDiv.appendChild(buyA); wrap.appendChild(armorDiv);

      modalContent.appendChild(wrap);
      const skip = document.createElement('button'); skip.textContent='Leave shop'; skip.onclick=()=>{ hideModal(); nextRoom(); };
      modalFooter.appendChild(skip); showModal();
    }
    else if(State.roomType==='HEAL'){
      const amt = Math.round(State.player.maxHp*0.4);
      modalContent.innerHTML = `<p>You discover a tranquil fountain. Restore <b>${amt} HP</b>?</p>`;
      const yes = document.createElement('button'); yes.textContent='Drink'; yes.onclick=()=>{ State.player.hp = clamp(State.player.hp+amt,0,State.player.maxHp); updateHUD(); hideModal(); nextRoom(); };
      const no = document.createElement('button'); no.textContent='Move on'; no.onclick=()=>{ hideModal(); nextRoom(); };
      modalFooter.appendChild(yes); modalFooter.appendChild(no); showModal();
    }
  }

  function replaceAbilityFlow(newAb, price){
    const grid = document.createElement('div'); grid.className='choices';
    State.player.abilities.forEach((cur,i)=>{
      const div = document.createElement('div'); div.className='choice';
      div.innerHTML = `<div class="title">Slot ${i+1}</div>
        <div class="row"><span style="color:${cur.color}">${cur.name}</span></div>
        <div class="row"><span>${cur.desc}</span></div>`;
      const btn = document.createElement('button'); btn.textContent = price?`Replace with ${newAb.name} (${price}g)`:`Replace with ${newAb.name}`;
      btn.onclick=()=>{ if(price && State.gold<price){ btn.textContent='Not enough gold'; return; } if(price) State.gold -= price; State.player.abilities[i] = newAb; renderAbilityButtons(); updateHUD(); hideModal(); nextRoom(); };
      div.appendChild(btn); grid.appendChild(div);
    });
    modalContent.innerHTML=''; modalContent.appendChild(grid);
  }

  function openLootModal(){
    modalTitle.textContent = State.roomType==='BOSS' ? 'Boss Defeated! Choose rewards' : 'Victory! Choose rewards';
    modalContent.innerHTML=''; modalFooter.innerHTML='';

    const root = document.createElement('div');

    // Ability picks
    const loot = [makeAbility(), makeAbility(), makeAbility()];
    const abWrap = document.createElement('div'); abWrap.className='choices';
    loot.forEach(ab=>{
      const div = document.createElement('div'); div.className='choice';
      div.innerHTML = `<div class="title" style="color:${ab.color}">${ab.name} <span class="pill">${ab.rarity}</span></div>
        <div class="row"><span>${ab.desc}</span></div>
        <div class="row"><span class="pill">CD ${ab.cd}</span><span class="pill">Range ${ab.range||1}</span>${ab.hits>1?`<span class="pill">Hits ${ab.hits}</span>`:''}</div>`;
      const btn = document.createElement('button'); btn.textContent='Take & replace...'; btn.onclick=()=> { replaceAbilityFlow(ab, 0); };
      div.appendChild(btn); abWrap.appendChild(div);
    });

    root.appendChild(document.createElement('h3')).textContent='Abilities';
    root.appendChild(abWrap);

    // Bonus: Armor or Talent
    const roll = Math.random();
    if(roll<0.5){
      const picks = [choice(ARMOR_POOL), choice(ARMOR_POOL)];
      const aw = document.createElement('div'); aw.className='choices';
      picks.forEach(arm=>{
        const d = document.createElement('div'); d.className='choice';
        d.innerHTML=`<div class='title'>${arm.name}</div><div class='row'>${arm.desc}</div>`;
        const b=document.createElement('button'); b.textContent='Equip'; b.onclick=()=>{ equipArmor(arm); hideModal(); afterRewards(); };
        d.appendChild(b); aw.appendChild(d);
      });
      root.appendChild(document.createElement('h3')).textContent='Bonus: Armor';
      root.appendChild(aw);
    } else {
      const clazz = CLASSES[State.player.class];
      if(clazz){
        const pool = [...clazz.talents];
        const picks = [pool.splice(rand(0,pool.length-1),1)[0], pool.splice(rand(0,Math.max(0,pool.length-1)),1)[0]].filter(Boolean);
        if(picks.length){
          const tw = document.createElement('div'); tw.className='choices';
          picks.forEach(t=>{
            const d=document.createElement('div'); d.className='choice'; d.innerHTML=`<div class='title'>${t.label}</div>`;
            const b=document.createElement('button'); b.textContent='Learn'; b.onclick=()=>{ t.apply(State.player); hideModal(); afterRewards(); };
            d.appendChild(b); tw.appendChild(d);
          });
          root.appendChild(document.createElement('h3')).textContent='Bonus: Talent';
          root.appendChild(tw);
        }
      }
    }

    modalContent.appendChild(root);

    const skip = document.createElement('button'); skip.textContent='Skip (keep current)'; skip.onclick=()=>{ hideModal(); afterRewards(); };
    modalFooter.appendChild(skip);
    showModal();
  }

  function afterRewards(){
    const wasBoss = (State.roomType==='BOSS');
    if(wasBoss){
      // Run ends for this stage
      modalTitle.textContent='Run Cleared!';
      modalContent.innerHTML = `<p>You extinguished the <b>${STAGES[State.stage].boss.name}</b> and calmed the <b>${STAGES[State.stage].name}</b>.</p>
        <p>Floor reached: <b>${State.floor}</b> • Gold: <span class='gold'><b>${State.gold}</b></span></p>`;
      modalFooter.innerHTML='';
      const btn = document.createElement('button'); btn.textContent='Start a new run'; btn.onclick=()=>{ startRun(); hideModal(); };
      modalFooter.appendChild(btn); showModal();
      return;
    }
    State.floor++; State.stageFloor++; nextRoom();
  }

  function gameOver(){
    modalTitle.textContent = 'Game Over';
    modalContent.innerHTML = `<p>You fell on <b>Floor ${State.floor}</b> with <span class="gold"><b>${State.gold} gold</b></span>.</p>`;
    modalFooter.innerHTML='';
    const btn = document.createElement('button'); btn.textContent='Restart run'; btn.onclick=()=>{ startRun(); hideModal(); };
    modalFooter.appendChild(btn); showModal();
  }

  // ===================== Input =====================
  function dirMove(dx,dy){
    if(State.roomType!=='BATTLE' && State.roomType!=='BOSS') return;
    if(State.turn!=='PLAYER') return;
    if(hasEffect(State.player, EFFECTS.FREEZE) || hasEffect(State.player, EFFECTS.STUN)) return;
    const nx = clamp(State.player.x+dx, 0, GRID_W-1);
    const ny = clamp(State.player.y+dy, 0, GRID_H-1);
    if(State.enemies.some(e=>e.x===nx && e.y===ny)) return;
    State.player.x = nx; State.player.y = ny;
    if(hasEffect(State.player, EFFECTS.BLEED)) { State.player.hp -= 6; addFloatText(State.player.x, State.player.y, '-6', '#f59999', 40); }
    endPlayerTurn();
  }
  const dpad = document.querySelector('.dpad');
  dpad.addEventListener('touchstart', (e)=>{ const t = e.target.closest('button'); if(!t) return; const dir = t.getAttribute('data-dir'); if(dir==='up') dirMove(0,-1); if(dir==='down') dirMove(0,1); if(dir==='left') dirMove(-1,0); if(dir==='right') dirMove(1,0); }, {passive:true});
  dpad.addEventListener('click', (e)=>{ const t = e.target.closest('button'); if(!t) return; const dir = t.getAttribute('data-dir'); if(dir==='up') dirMove(0,-1); if(dir==='down') dirMove(0,1); if(dir==='left') dirMove(-1,0); if(dir==='right') dirMove(1,0); });
  document.getElementById('loadoutBtn').onclick = openLoadoutModal;
  document.getElementById('restartBtn').onclick = ()=>{ startRun(); };

  // Ability buttons
  const abilitiesEl = document.getElementById('abilities');
  function renderAbilityButtons(){
    abilitiesEl.innerHTML='';
    State.player.abilities.forEach((ab, idx)=>{
      const b = document.createElement('button');
      b.innerHTML = `<div style="font-size:12px;opacity:.8">Slot ${idx+1} • <span style="color:${ab.color}">${ab.rarity}</span></div>
        <div>${ab.name}</div>
        <div class="smallRow"><span class="pill">CD ${ab.cdLeft||0}/${ab.cd}</span>${ab.range?`<span class="pill">R${ab.range}</span>`:''}${ab.hits>1?`<span class="pill">x${ab.hits}</span>`:''}${ab.element?`<span class="pill">${ab.element}</span>`:''}</div>`;
      if(ab.cdLeft>0) b.classList.add('cooldown');
      b.onclick = ()=> selectAbility(idx);
      abilitiesEl.appendChild(b);
    });
  }

  function selectAbility(idx){
    const ab = State.player.abilities[idx];
    if((State.roomType!=='BATTLE' && State.roomType!=='BOSS') || State.turn!=='PLAYER') return;
    if(ab.cdLeft>0) return;
    State.selection = { idx, ab };
    if(ab.type==='tome'){
      const spend = Math.min(2, State.player.pages);
      if(spend>0){ State.player.pages -= spend; State.pendingHits = (State.pendingHits||0) + spend; addFloatText(State.player.x, State.player.y, `+${spend} hit`, '#d0c7ff', 45); }
      ab.cdLeft = ab.cd; State.selection=null; updateHUD(); return;
    }
    if(ab.type==='stealth'){
      addEffect(State.player, EFFECTS.STEALTH, 1 + (State.player.armorMods?.stealthPlus||0));
      addFloatText(State.player.x, State.player.y, 'STEALTH', '#9ad5ff', 45);
      ab.cdLeft = ab.cd; State.selection=null; endPlayerTurn();
    }
  }

  // ===================== Battle Flow =====================
  function startPlayerTurn(){
    const {skip} = processEffects(State.player);
    if(State.player.class==='Cleric' && State.player.talents.Mercy && Math.random()<0.2){ State.player.abilities.forEach(a=>{ if(a.cdLeft>0) a.cdLeft--; }); addFloatText(State.player.x, State.player.y, 'Mercy', '#c9ffe5', 40); }
    renderAbilityButtons(); updateHUD();
    if(State.player.hp<=0){ gameOver(); return; }
    if(skip){ endPlayerTurn(true); return; }
  }

  function endPlayerTurn(skipped=false){
    State.player.abilities.forEach((ab)=>{ if(ab.cdLeft>0) ab.cdLeft = Math.max(0, ab.cdLeft-1); });
    if(State.player.class==='Rogue' && CLASSES.Rogue.passiveEndTurn) CLASSES.Rogue.passiveEndTurn();
    if(!skipped && State.extraActions>0){ State.extraActions--; startPlayerTurn(); return; }
    State.turn = 'ENEMY'; enemyTurn();
  }

  function enemyTurn(){
    for(const e of [...State.enemies]){
      const {skip} = processEffects(e);
      if(e.hp<=0) continue;
      if(skip){ continue; }

      // move toward player
      let dx = Math.sign(State.player.x - e.x);
      let dy = Math.sign(State.player.y - e.y);
      const wantXFirst = Math.abs(State.player.x-e.x) > Math.abs(State.player.y-e.y);
      function tryMove(nx, ny){
        if(nx<0||ny<0||nx>=GRID_W||ny>=GRID_H) return false;
        if(State.enemies.some(o=>o!==e && o.x===nx && o.y===ny)) return false;
        if(State.player.x===nx && State.player.y===ny) return false;
        e.x=nx; e.y=ny; return true;
      }
      if(wantXFirst){ if(!tryMove(e.x+dx, e.y)) tryMove(e.x, e.y+dy); } else { if(!tryMove(e.x, e.y+dy)) tryMove(e.x+dx, e.y); }

      if(hasEffect(e, EFFECTS.BLEED)) e.hp -= 6;

      // attack if adjacent
      if(Math.abs(e.x-State.player.x)+Math.abs(e.y-State.player.y)===1){
        let dmg = e.dmg;
        if(State.player.shields>0){ const soak = Math.min(State.player.shields, dmg); State.player.shields -= soak; dmg -= soak; }
        if(dmg>0){
          State.player.hp -= dmg; addFloatText(State.player.x, State.player.y, `-${dmg}`, 'var(--bad)', 50);
          screenShake(8); FX.hitFlash = Math.min(0.3, FX.hitFlash+0.2);
          if(State.player.class==='Fighter' && State.player.talents.Riposte && Math.random()<0.25){ e.hp -= 6; addFloatText(e.x, e.y, '-6 (Riposte)', '#ffe0a5', 40); }
        }
      }
    }

    State.enemies = State.enemies.filter(e=>e.hp>0);
    updateHUD();
    if(State.player.hp<=0){ gameOver(); return; }
    State.turn = 'PLAYER'; startPlayerTurn();
  }

  // ===================== Targeting via tapping grid =====================
  canvas.addEventListener('click', handleTap);
  canvas.addEventListener('touchstart', (e)=>{ const t=e.changedTouches[0]; handleTap({clientX:t.clientX, clientY:t.clientY}); }, {passive:true});

  function handleTap(ev){
    if((State.roomType!=='BATTLE' && State.roomType!=='BOSS') || State.turn!=='PLAYER') return;
    const x = (ev.clientX||0)*DPR, y=(ev.clientY||0)*DPR;
    const gx = Math.floor((x - gridOffsetX)/TILE); const gy = Math.floor((y - gridOffsetY)/TILE);
    if(gx<0||gy<0||gx>=GRID_W||gy>=GRID_H) return;

    if(State.selection){
      const {ab} = State.selection;
      const dist = Math.abs(gx-State.player.x)+Math.abs(gy-State.player.y);
      if(ab.type==='attack'){
        if(dist<=ab.range){
          const target = State.enemies.find(e=>e.x===gx && e.y===gy);
          if(target){
            resolveAttack(State.player, target, ab);
            if(State.enemies.length===0){
              const goldGain = rand(15,30) + 5*(State.floor-1); State.gold += goldGain; updateHUD(); openLootModal(); return;
            }
            State.selection=null; endPlayerTurn();
          }
        }
      } else if(ab.type==='heal'){
        if(gx===State.player.x && gy===State.player.y){
          let amt = ab.heal; if(State.player.class==='Cleric' && State.player.talents.Sanctify) amt = Math.round(amt*1.2);
          State.player.hp = clamp(State.player.hp + amt, 0, State.player.maxHp);
          addFloatText(State.player.x, State.player.y, `+${amt}`, 'var(--good)', 50);
          if(State.player.class==='Cleric' && CLASSES.Cleric.passiveOnHeal) CLASSES.Cleric.passiveOnHeal(amt);
          ab.cdLeft = ab.cd; State.selection=null; updateHUD(); endPlayerTurn();
        }
      } else if(ab.type==='shield'){
        if(gx===State.player.x && gy===State.player.y){ State.player.shields += ab.shield; addFloatText(State.player.x, State.player.y, `+${ab.shield}🛡`, '#bde7ff', 40); ab.cdLeft=ab.cd; State.selection=null; endPlayerTurn(); }
      } else if(ab.type==='move'){
        if(dist<=ab.range && !State.enemies.some(e=>e.x===gx && e.y===gy)){
          State.player.x = gx; State.player.y = gy; addFloatText(gx, gy, 'BLINK', '#8ad1ff', 40); ab.cdLeft = ab.cd; State.selection=null; endPlayerTurn();
        }
      }
    }
  }

  function resolveAttack(attacker, target, ab){
    let hits = ab.hits + (State.pendingHits||0); State.pendingHits = 0;
    // Flurry (Rogue) — first attack each battle
    if(State.player===attacker && State.player.class==='Rogue' && State.player.talents.Flurry && !State._flurryUsed){ hits++; State._flurryUsed=true; addFloatText(attacker.x, attacker.y, 'FLURRY +1', '#d6b8ff', 45); }

    for(let i=0;i<hits;i++){
      let dmg = ab.dmg;
      if(State.player===attacker && State.player.class==='Fighter' && State.player.talents.BrutalStrikes) dmg = Math.round(dmg*1.2);
      if(State.player===attacker && State.player.talents.Conduction && hasEffect(target, EFFECTS.SHOCK)) dmg = Math.round(dmg*1.25);
      if(State.player===attacker && State.player.talents.Expose && hasEffect(target, EFFECTS.BLEED)) dmg = Math.round(dmg*1.3);

      dmg = onHitCombos(attacker, target, dmg, {element:ab.element});
      target.hp -= dmg; addFloatText(target.x, target.y, `-${dmg}`, 'var(--bad)', 50);

      // Apply element status
      if(ab.element==='Flaming') addEffect(target, EFFECTS.BURN, 3, (4 + (State.player.armorMods?.burnPlus||0)));
      if(ab.element==='Frost'){ addEffect(target, EFFECTS.FREEZE, 1 + (State.player.talents.Glacier?1:0)); }
      if(ab.element==='Shock'){ addEffect(target, EFFECTS.SHOCK, 1 + (State.player.armorMods?.shockPlus||0)); }
      if(ab.element==='Venom') addEffect(target, EFFECTS.POISON, 3, 5);
      if(ab.element==='Shadow') addEffect(target, EFFECTS.BLEED, 3, 0);

      if(State.player===attacker && State.player.class==='Wizard' && State.player.talents.ArcaneBattery){ State.player._casts=(State.player._casts||0)+1; if(State.player._casts%3===0) { ab.cdLeft=0; addFloatText(attacker.x, attacker.y, 'BATTERY!', '#b6f7ff', 45); } }
      if(ab.element==='Shock' && hasEffect(target, EFFECTS.BURN) && State.player.armorMods?.overloadPlus){ splashDamage(target.x,target.y, State.player.armorMods.overloadPlus); }
    }

    if(target.hp<=0 && State.player===attacker && State.player.class==='Fighter') CLASSES.Fighter.passiveOnKill();
    ab.cdLeft = ab.cd; State.selection=null; State.enemies = State.enemies.filter(e=>e.hp>0);
  }

  // ===================== Rendering =====================
  function drawGrid(){
    ctx.save();
    if(FX.shake>0){ ctx.translate((Math.random()-0.5)*FX.shake, (Math.random()-0.5)*FX.shake); FX.shake*=0.92; if(FX.shake<0.2) FX.shake=0; }

    const g = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 10, canvas.width/2, canvas.height/2, Math.max(canvas.width,canvas.height)/1.2);
    g.addColorStop(0, '#101635'); g.addColorStop(1, '#060914'); ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const gx = gridOffsetX + x*TILE; const gy = gridOffsetY + y*TILE;
        ctx.fillStyle = ((x+y)%2===0)?'#111a3a':'#0e1631'; ctx.fillRect(gx, gy, TILE-2, TILE-2);
      }
    }

    // selection highlights
    if(State.selection){
      const ab = State.selection.ab; ctx.globalAlpha = 0.35; ctx.fillStyle = ab.type==='attack'?'#ff6565':(ab.type==='move'?'#8ad1ff':'#7cf59a');
      for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++){
        const dist = Math.abs(x-State.player.x)+Math.abs(y-State.player.y);
        if((ab.type==='attack'||ab.type==='move') && dist<=ab.range) ctx.fillRect(gridOffsetX+x*TILE, gridOffsetY+y*TILE, TILE-2, TILE-2);
        if((ab.type==='heal'||ab.type==='shield') && x===State.player.x && y===State.player.y) ctx.fillRect(gridOffsetX+x*TILE, gridOffsetY+y*TILE, TILE-2, TILE-2);
      }
      ctx.globalAlpha = 1;
    }

    // enemies
    for(const e of State.enemies){
      const gx = gridOffsetX + e.x*TILE + TILE/2; const gy = gridOffsetY + e.y*TILE + TILE/2;
      if(images.slime){ ctx.drawImage(images.slime, gx-TILE/2+8, gy-TILE/2+8, TILE-16, TILE-16); }
      else { ctx.fillStyle = '#7cf59a'; ctx.beginPath(); ctx.arc(gx, gy, TILE*0.32, 0, Math.PI*2); ctx.fill(); }
      const baseHp = e.isBoss ? STAGES[State.stage].boss.hp : (30 + 12*State.floor);
      const pct = clamp(e.hp/baseHp,0,1);
      ctx.fillStyle = '#000'; ctx.fillRect(gx-TILE*0.35, gy-TILE*0.55, TILE*0.7, 6);
      ctx.fillStyle = e.isBoss ? 'var(--boss)' : '#ff7a7a'; ctx.fillRect(gx-TILE*0.35, gy-TILE*0.55, TILE*0.7*pct, 6);
      if(e.isBoss){ ctx.font = `${Math.floor(12*DPR)}px sans-serif`; ctx.fillStyle='#ffd6f2'; ctx.textAlign='center'; ctx.fillText('👑 '+(e.name||'Boss'), gx, gy - TILE*0.6); }
    }

    // player
    const px = gridOffsetX + State.player.x*TILE + TILE/2; const py = gridOffsetY + State.player.y*TILE + TILE/2;
    if(images.hero){ ctx.drawImage(images.hero, px-TILE/2+4, py-TILE/2, TILE-8, TILE-8); }
    else { ctx.fillStyle = '#8ad1ff'; ctx.fillRect(px-TILE*0.35, py-TILE*0.35, TILE*0.7, TILE*0.7); }

    if(State.player.shields>0){ ctx.strokeStyle = '#8ad1ff'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(px,py,TILE*0.42,0,Math.PI*2); ctx.stroke(); }
    if(hasEffect(State.player, EFFECTS.STEALTH)){
      ctx.globalAlpha = 0.35; ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(px,py,TILE*0.45,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
      ctx.font = `${Math.floor(12*DPR)}px sans-serif`; ctx.fillStyle='#9ad5ff'; ctx.textAlign='center'; ctx.fillText('STEALTH', px, py - TILE*0.6);
    }

    // floating text
    for(const f of FX.floaters){
      f.x += 0; f.y += f.vy; f.ttl--; const a = Math.max(0, f.ttl/f.life);
      ctx.globalAlpha = a; ctx.fillStyle = f.color; ctx.font = `${Math.floor(16*DPR)}px sans-serif`; ctx.textAlign='center'; ctx.fillText(f.text, f.x, f.y);
      ctx.globalAlpha = 1;
    }
    FX.floaters = FX.floaters.filter(f=>f.ttl>0);

    // banner
    ctx.globalAlpha = 0.25; ctx.fillStyle = '#fff'; ctx.font = `${Math.floor(24*DPR)}px sans-serif`; ctx.textAlign = 'center';
    ctx.fillText(State.turn==='PLAYER'?'Your Turn':'Enemy Turn', canvas.width/2, gridOffsetY - 14); ctx.globalAlpha = 1;

    // toasts
    let ty = 40*DPR; for(const t of FX.toasts){ ctx.globalAlpha = Math.min(1, t.time/30); ctx.fillStyle = t.color; ctx.font = `${Math.floor(22*DPR)}px sans-serif`; ctx.textAlign='center'; ctx.fillText(t.text, canvas.width/2, ty); ctx.globalAlpha = 1; t.time--; ty += 28*DPR; }
    FX.toasts = FX.toasts.filter(t=>t.time>0);

    // hit flash overlay
    if(FX.hitFlash>0){ ctx.fillStyle = 'rgba(255,60,60,'+FX.hitFlash+')'; ctx.fillRect(0,0,canvas.width,canvas.height); FX.hitFlash=Math.max(0, FX.hitFlash-0.02); }

    ctx.restore();
  }

  function loop(){ drawGrid(); requestAnimationFrame(loop); }
  requestAnimationFrame(loop);

  // ===================== Run Setup =====================
  function openClassSelect(){
    modalTitle.textContent='Choose Your Class'; modalContent.innerHTML=''; modalFooter.innerHTML='';
    const wrap=document.createElement('div'); wrap.className='choices';
    Object.entries(CLASSES).forEach(([name,def])=>{
      const d=document.createElement('div'); d.className='choice';
      d.innerHTML=`<div class='title'>${name}</div><div class='row'>${def.desc}</div>`;
      const b=document.createElement('button'); b.textContent=`Become ${name}`; b.onclick=()=>{ State.player.class=name; if(def.onStart) def.onStart(State.player); State.player.abilities = newAbilitySet(); State._flurryUsed=false; renderAbilityButtons(); updateHUD(); hideModal(); nextRoom(); };
      d.appendChild(b); wrap.appendChild(d);
    });
    modalContent.appendChild(wrap); showModal();
  }

  function startRun(){
    State.gold=0; State.floor=1; State.stage=0; State.stageFloor=1; State.storyIndex=0;
    State.player.hp=100; State.player.maxHp=100; State.player.shields=0; State.player.effects=[]; State.player.pages=0; State.player.talents={}; State.player.armor=null; State.player.armorMods={}; State.pendingHits=0; State.extraActions=0; State._flurryUsed=false;
    renderAbilityButtons(); updateHUD(); openClassSelect();
    addToast('A new run begins...', '#cde3ff', 120);
  }

  // Keep UI refreshed
  setInterval(()=>{ renderAbilityButtons(); }, 300);

  // Initialize
  startRun();
})();
</script>

<!--
Sprite sources (CC0 / public domain, used via direct hotlink with graceful fallback if unreachable):
- Kenney.nl asset packs. If these URLs fail, the game draws simple shapes instead.
  https://kenney.nl/
-->
</body>
</html>
