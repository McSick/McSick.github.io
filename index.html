<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Fantasy Roguelite — 0x72 Tileset Edition</title>
  <style>
    :root {
      --ui-bg: rgba(20, 20, 28, 0.85);
      --ui-text: #f0f4ff;
      --accent: #8ad1ff;
      --good: #7cf59a;
      --bad: #ff8a8a;
      --gold: #ffd76a;
      --shadow: #c18cff;
      --boss: #ff7ad6;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      background: #0f1220;
      color: var(--ui-text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
      height: 100%;
      overflow: hidden;
      touch-action: none;
    }

    #gameWrap {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #0a0d18;
    }

    /* HUD */
    .hud {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      padding: 8px 10px;
      display: grid;
      grid-template-columns: 1fr auto auto auto;
      gap: 8px;
      align-items: center;
      pointer-events: none;
      background: linear-gradient(to bottom, rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0));
      font-weight: 600;
      text-shadow: 0 1px 2px #000;
    }

    .leftStack {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .hud .stat {
      pointer-events: auto;
      background: var(--ui-bg);
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.07);
    }

    .hud .hpBar {
      width: 140px;
      height: 12px;
      background: #2a2f44;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid #000;
    }

    .hud .hpFill {
      height: 100%;
      background: linear-gradient(90deg, #5fff9b, #2ee6ff);
    }

    .miniBtn {
      pointer-events: auto;
      padding: 8px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: #1a1f3f;
      color: var(--ui-text);
      font-weight: 800;
    }

    /* Controls */
    .controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 10px;
      pointer-events: none;
    }

    .dpad {
      pointer-events: auto;
      width: 200px;
      height: 200px;
      position: relative;
    }

    .dpad button {
      position: absolute;
      width: 70px;
      height: 70px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: var(--ui-bg);
      color: var(--ui-text);
      font-size: 18px;
      font-weight: 700;
    }

    .dpad .up {
      top: 0;
      left: 65px;
    }

    .dpad .down {
      bottom: 0;
      left: 65px;
    }

    .dpad .left {
      left: 0;
      top: 65px;
    }

    .dpad .right {
      right: 0;
      top: 65px;
    }

    .abilities {
      pointer-events: auto;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      width: min(60vw, 380px);
    }

    .abilities button {
      height: 86px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: var(--ui-bg);
      color: var(--ui-text);
      font-size: 13px;
      font-weight: 700;
      padding: 6px;
      text-align: left;
    }

    /* Make all buttons show the hand cursor */
    button,
    .abilities button,
    .dpad button,
    .miniBtn,
    .footerRow button {
      cursor: pointer;
    }


    .abilities button.cooldown {
      opacity: 0.5;
      filter: grayscale(0.5);
    }

    .smallRow {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .pill {
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      font-size: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    /* Modal */
    .modal {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(3, 6, 12, 0.75);
      backdrop-filter: blur(6px);
    }

    .modal.show {
      display: flex;
    }

    .card {
      width: min(92vw, 920px);
      max-height: 90vh;
      overflow: auto;
      background: #121528;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 18px;
      padding: 14px;
      box-shadow: 0 10px 60px rgba(0, 0, 0, 0.5);
    }

    .choices {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px;
    }

    .choice {
      background: #0f1328;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 14px;
      padding: 10px;
    }

    .choice .title {
      font-weight: 800;
      margin-bottom: 6px;
    }

    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .footerRow {
      margin-top: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .footerRow button {
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: #1a1f3f;
      color: var(--ui-text);
      font-weight: 800;
    }

    button,
    .abilities button,
    .dpad button,
    .miniBtn,
    .footerRow button {
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>

<body>
  <div id="gameWrap">
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="leftStack">
        <div class="stat">Room: <span id="roomType">-</span> <span id="roomTheme" style="opacity:.8"></span></div>
        <div class="stat smallRow">
          <span>HP</span>
          <div class="hpBar">
            <div id="hpFill" class="hpFill" style="width:100%"></div>
          </div>
        </div>
        <div class="stat">Gold: <span id="gold" class="gold">0</span></div>
        <div class="stat">Class: <span id="clazz" class="class">-</span></div>
        <div class="stat">Pages: <span id="pages" class="pages">0</span></div>
        <div class="stat">Armor: <span id="armorName" class="armor">None</span></div>
        <div class="stat smallRow">
          <span>Stage:</span>
          <div class="progress"
            style="width:200px; height:10px; background:#283050; border-radius:999px; overflow:hidden; border:1px solid rgba(255,255,255,0.08)">
            <div id="stageProg" class="progressFill"
              style="height:100%; width:0%; background:linear-gradient(90deg,#6fe7ff,#b58cff)"></div>
          </div>
          <span id="stageLabel" style="opacity:.8"></span>
        </div>
        <div class="stat" id="abilityInfo"
          style="max-width:38vw; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; opacity:.9">
          Click/tap an ability, then tap a tile. Hover to see details here.
        </div>


      </div>
      <div class="stat"><button id="loadoutBtn" class="miniBtn">☰ Loadout</button></div>
      <div class="stat"><button id="muteBtn" class="miniBtn" title="Toggle sound">🔊</button></div>
      <div class="stat"><button id="restartBtn" class="miniBtn">↻ Restart</button></div>
    </div>

    <div class="controls">
      <div class="dpad">
        <button class="up" data-dir="up">▲</button>
        <button class="down" data-dir="down">▼</button>
        <button class="left" data-dir="left">◀</button>
        <button class="right" data-dir="right">▶</button>
      </div>
      <div class="abilities" id="abilities"></div>
    </div>

    <div class="modal" id="modal">
      <div class="card" id="modalCard">
        <h2 id="modalTitle">Loot!</h2>
        <div id="modalContent"></div>
        <div class="footerRow" id="modalFooter"></div>
      </div>
    </div>
  </div>

  <script>
    (function () {
      // ========= util =========
      // Long-press tuning
      const LONG_PRESS_MS = 700;   // hold duration to trigger details
      const MOVE_TOLERANCE = 10;   // px of finger drift allowed

      function victoryCheck(origin = '') {
        // Only matters in combat rooms
        if (!(State.roomType === 'BATTLE' || State.roomType === 'BOSS')) return false;
        if (State.enemies.length > 0) return false;
        if (State._lootShown) return true; // guard against double-open

        State._lootShown = true;
        const goldGain = (State.roomType === 'BOSS')
          ? rand(60, 90) + 10 * (State.floor - 1)
          : rand(15, 30) + 5 * (State.floor - 1);

        State.gold += goldGain;
        updateHUD();

        // slight delay so the render can settle
        setTimeout(() => openLootModal(), 50);
        return true;
      }


      const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
      const choice = arr => arr[Math.floor(Math.random() * arr.length)];
      const clamp = (v, mi, ma) => Math.max(mi, Math.min(ma, v));

      // ========= canvas =========
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      function resize() { canvas.width = Math.floor(window.innerWidth * DPR); canvas.height = Math.floor(window.innerHeight * DPR); canvas.style.width = '100%'; canvas.style.height = '100%'; }
      window.addEventListener('resize', resize, { passive: true }); resize();

      // grid
      const GRID_W = 8, GRID_H = 6, TILE = Math.floor(Math.min(canvas.width / (GRID_W + 2), canvas.height / (GRID_H + 4)));
      const offX = Math.floor((canvas.width - GRID_W * TILE) / 2);
      const offY = Math.floor((canvas.height - GRID_H * TILE) / 2);
      const BASE_UNIT = 16; // atlas tile unit
      const SCALE = (TILE - 2) / BASE_UNIT;

      // ========= atlas: 0x72 tileset.png =========
      const ATLAS_SRC = 'tileset.png';
      const atlas = new Image(); atlas.onload = () => { ASSETS.ready = true; }; atlas.onerror = () => { console.warn('tileset.png not found; using fallbacks'); ASSETS.ready = false; }; atlas.src = ATLAS_SRC;
      const ASSETS = { ready: false, frames: {} };

      // Parse the frame list the user sent (name x y w h)
      function parseFrames(text) {
        const frames = {};
        text.trim().split('\n').forEach(line => {
          line = line.trim(); if (!line) return;
          const parts = line.split(/\s+/);
          const name = parts[0];
          const nums = parts.slice(1).map(n => parseInt(n, 10));
          if (nums.length >= 4) { const [x, y, w, h] = nums; frames[name] = { x, y, w, h }; }
        });
        return frames;
      }

      ASSETS.frames = parseFrames(`
big_demon_idle_anim_f0 16 428 32 36
big_demon_idle_anim_f1 48 428 32 36
big_demon_idle_anim_f2 80 428 32 36
big_demon_idle_anim_f3 112 428 32 36
big_demon_run_anim_f0 144 428 32 36
big_demon_run_anim_f1 176 428 32 36
big_demon_run_anim_f2 208 428 32 36
big_demon_run_anim_f3 240 428 32 36
big_zombie_idle_anim_f0 16 332 32 36
big_zombie_idle_anim_f1 48 332 32 36
big_zombie_idle_anim_f2 80 332 32 36
big_zombie_idle_anim_f3 112 332 32 36
big_zombie_run_anim_f0 144 332 32 36
big_zombie_run_anim_f1 176 332 32 36
big_zombie_run_anim_f2 208 332 32 36
big_zombie_run_anim_f3 240 332 32 36
bomb_f0 288 320 16 16
bomb_f1 304 320 16 16
bomb_f2 320 320 16 16
chest_empty_open_anim_f0 304 400 16 16
chest_empty_open_anim_f1 320 400 16 16
chest_empty_open_anim_f2 336 400 16 16
chest_full_open_anim_f0 304 416 16 16
chest_full_open_anim_f1 320 416 16 16
chest_full_open_anim_f2 336 416 16 16
chest_mimic_open_anim_f0 304 432 16 16
chest_mimic_open_anim_f1 320 432 16 16
chest_mimic_open_anim_f2 336 432 16 16
coin_anim_f0 289 385 6 7
coin_anim_f1 297 385 6 7
coin_anim_f2 305 385 6 7
coin_anim_f3 313 385 6 7
flask_big_blue 304 336 16 16
flask_big_red 288 336 16 16
flask_big_green 320 336 16 16
flask_big_yellow 336 336 16 16
flask_blue 304 352 16 16
flask_red 288 352 16 16
flask_green 320 352 16 16
flask_yellow 336 352 16 16
wizzard_f_hit_anim_f0 256 132 16 28
wizzard_f_idle_anim_f0 128 132 16 28
wizzard_f_idle_anim_f1 144 132 16 28
wizzard_f_idle_anim_f2 160 132 16 28
wizzard_f_idle_anim_f3 176 132 16 28
wizzard_f_run_anim_f0 192 132 16 28
wizzard_f_run_anim_f1 208 132 16 28
wizzard_f_run_anim_f2 224 132 16 28
wizzard_f_run_anim_f3 240 132 16 28
wizzard_m_hit_anim_f0 256 164 16 28
wizzard_m_idle_anim_f0 128 164 16 28
wizzard_m_idle_anim_f1 144 164 16 28
wizzard_m_idle_anim_f2 160 164 16 28
wizzard_m_idle_anim_f3 176 164 16 28
wizzard_m_run_anim_f0 192 164 16 28
wizzard_m_run_anim_f1 208 164 16 28
wizzard_m_run_anim_f2 224 164 16 28
wizzard_m_run_anim_f3 240 164 16 28
dwarf_m_idle_anim_f0 128 292 16 28
imp_idle_anim_f0 368 64 16 16
imp_idle_anim_f1 384 64 16 16
imp_idle_anim_f2 400 64 16 16
imp_idle_anim_f3 416 64 16 16
imp_run_anim_f0 432 64 16 16
imp_run_anim_f1 448 64 16 16
imp_run_anim_f2 464 64 16 16
imp_run_anim_f3 480 64 16 16
lizard_f_hit_anim_f0 256 196 16 28
lizard_f_idle_anim_f0 128 196 16 28
lizard_f_idle_anim_f1 144 196 16 28
lizard_f_idle_anim_f2 160 196 16 28
lizard_f_idle_anim_f3 176 196 16 28
lizard_f_run_anim_f0 192 196 16 28
lizard_f_run_anim_f1 208 196 16 28
lizard_f_run_anim_f2 224 196 16 28
lizard_f_run_anim_f3 240 196 16 28
dwarf_m_idle_anim_f1 144 292 16 28
dwarf_m_idle_anim_f2 160 292 16 28
dwarf_m_idle_anim_f3 176 292 16 28
dwarf_m_run_anim_f0 192 292 16 28
dwarf_m_run_anim_f1 208 292 16 28
dwarf_m_run_anim_f2 224 292 16 28
dwarf_m_run_anim_f3 240 292 16 28
dwarf_m_hit_anim_f0 256 292 16 28
knight_f_hit_anim_f0 256 68 16 28
knight_f_idle_anim_f0 128 68 16 28
knight_f_idle_anim_f1 144 68 16 28
knight_f_idle_anim_f2 160 68 16 28
knight_f_idle_anim_f3 176 68 16 28
knight_f_run_anim_f0 192 68 16 28
knight_f_run_anim_f1 208 68 16 28
knight_f_run_anim_f2 224 68 16 28
knight_f_run_anim_f3 240 68 16 28
dwarf_f_idle_anim_f0 128 260 16 28
dwarf_f_idle_anim_f1 144 260 16 28
dwarf_f_idle_anim_f2 160 260 16 28
dwarf_f_idle_anim_f3 176 260 16 28
dwarf_f_run_anim_f0 192 260 16 28
dwarf_f_run_anim_f1 208 260 16 28
dwarf_f_run_anim_f2 224 260 16 28
dwarf_f_run_anim_f3 240 260 16 28
dwarf_f_hit_anim_f0 256 260 16 28
wogol_idle_anim_f0 368 249 16 23
wogol_idle_anim_f1 384 249 16 23
wogol_idle_anim_f2 400 249 16 23
wogol_idle_anim_f3 416 249 16 23
wogol_run_anim_f0 432 249 16 23
wogol_run_anim_f1 448 249 16 23
wogol_run_anim_f2 464 249 16 23
wogol_run_anim_f3 480 249 16 23
zombie_anim_f10 368 136 16 16
zombie_anim_f1 384 136 16 16
zombie_anim_f2 400 136 16 16
zombie_anim_f3 416 136 16 16
tiny_zombie_idle_anim_f0 368 16 16 16
tiny_zombie_idle_anim_f1 384 16 16 16
tiny_zombie_idle_anim_f2 400 16 16 16
tiny_zombie_idle_anim_f3 416 16 16 16
tiny_zombie_run_anim_f0 432 16 16 16
tiny_zombie_run_anim_f1 448 16 16 16
tiny_zombie_run_anim_f2 464 16 16 16
tiny_zombie_run_anim_f3 480 16 16 16
goblin_idle_anim_f0 368 40 16 16
goblin_idle_anim_f1 384 40 16 16
goblin_idle_anim_f2 400 40 16 16
goblin_idle_anim_f3 416 40 16 16
goblin_run_anim_f0 432 40 16 16
goblin_run_anim_f1 448 40 16 16
goblin_run_anim_f2 464 40 16 16
goblin_run_anim_f3 480 40 16 16
ice_zombie_anim_f0 432 136 16 16
ice_zombie_anim_f1 448 136 16 16
ice_zombie_anim_f2 464 136 16 16
ice_zombie_anim_f3 480 136 16 16
knight_m_idle_anim_f0 128 100 16 28
knight_m_idle_anim_f1 144 100 16 28
knight_m_idle_anim_f2 160 100 16 28
knight_m_idle_anim_f3 176 100 16 28
knight_m_run_anim_f0 192 100 16 28
knight_m_run_anim_f1 208 100 16 28
knight_m_run_anim_f2 224 100 16 28
knight_m_run_anim_f3 240 100 16 28
knight_m_hit_anim_f0 256 100 16 28
crate 288 408 16 24
edge_down 96 128 16 16
orc_shaman_idle_anim_f0 368 201 16 23
orc_shaman_idle_anim_f1 384 201 16 23
orc_shaman_idle_anim_f2 400 201 16 23
orc_shaman_idle_anim_f3 416 201 16 23
orc_shaman_run_anim_f0 432 201 16 23
orc_shaman_run_anim_f1 448 201 16 23
orc_shaman_run_anim_f2 464 201 16 23
orc_shaman_run_anim_f3 480 201 16 23
swampy_anim_f0 432 112 16 16
swampy_anim_f1 448 112 16 16
swampy_anim_f2 464 112 16 16
swampy_anim_f3 480 112 16 16
muddy_anim_f0 368 112 16 16
muddy_anim_f1 384 112 16 16
muddy_anim_f2 400 112 16 16
muddy_anim_f3 416 112 16 16
necromancer_anim_f0 368 225 16 23
necromancer_anim_f1 384 225 16 23
necromancer_anim_f2 400 225 16 23
necromancer_anim_f3 416 225 16 23
masked_orc_idle_anim_f0 368 153 16 23
masked_orc_idle_anim_f1 384 153 16 23
masked_orc_idle_anim_f2 400 153 16 23
masked_orc_idle_anim_f3 416 153 16 23
masked_orc_run_anim_f0 432 153 16 23
masked_orc_run_anim_f1 448 153 16 23
masked_orc_run_anim_f2 464 153 16 23
masked_orc_run_anim_f3 480 153 16 23
orc_warrior_idle_anim_f0 368 177 16 23
orc_warrior_idle_anim_f1 384 177 16 23
orc_warrior_idle_anim_f2 400 177 16 23
orc_warrior_idle_anim_f3 416 177 16 23
orc_warrior_run_anim_f0 432 177 16 23
orc_warrior_run_anim_f1 448 177 16 23
orc_warrior_run_anim_f2 464 177 16 23
orc_warrior_run_anim_f3 480 177 16 23
skelet_idle_anim_f0 368 88 16 16
skelet_idle_anim_f1 384 88 16 16
skelet_idle_anim_f2 400 88 16 16
skelet_idle_anim_f3 416 88 16 16
skelet_run_anim_f0 432 88 16 16
skelet_run_anim_f1 448 88 16 16
skelet_run_anim_f2 464 88 16 16
skelet_run_anim_f3 480 88 16 16
skull 288 432 16 16
ogre_idle_anim_f0 16 380 32 36
ogre_idle_anim_f1 48 380 32 36
ogre_idle_anim_f2 80 380 32 36
ogre_idle_anim_f3 112 380 32 36
ogre_run_anim_f0 144 380 32 36
ogre_run_anim_f1 176 380 32 36
ogre_run_anim_f2 208 380 32 36
ogre_run_anim_f3 240 380 32 36
ui_heart_empty 321 370 13 12
ui_heart_full 289 370 13 12
ui_heart_half 305 370 13 12
doc_idle_anim_f0 368 345 16 23
doc_idle_anim_f1 384 345 16 23
doc_idle_anim_f2 400 345 16 23
doc_idle_anim_f3 416 345 16 23
doc_run_anim_f0 432 345 16 23
doc_run_anim_f1 448 345 16 23
doc_run_anim_f2 464 345 16 23
doc_run_anim_f3 480 345 16 23
pumpkin_dude_idle_anim_f0 368 321 16 23
pumpkin_dude_idle_anim_f1 384 321 16 23
pumpkin_dude_idle_anim_f2 400 321 16 23
pumpkin_dude_idle_anim_f3 416 321 16 23
pumpkin_dude_run_anim_f0 432 321 16 23
pumpkin_dude_run_anim_f1 448 321 16 23
pumpkin_dude_run_anim_f2 464 321 16 23
pumpkin_dude_run_anim_f3 480 321 16 23
angel_idle_anim_f0 368 304 16 16
angel_idle_anim_f1 384 304 16 16
angel_idle_anim_f2 400 304 16 16
angel_idle_anim_f3 416 304 16 16
angel_run_anim_f0 432 304 16 16
angel_run_anim_f1 448 304 16 16
angel_run_anim_f2 464 304 16 16
angel_run_anim_f3 480 304 16 16
chort_idle_anim_f0 368 273 16 23
chort_idle_anim_f1 384 273 16 23
chort_idle_anim_f2 400 273 16 23
chort_idle_anim_f3 416 273 16 23
chort_run_anim_f0 432 273 16 23
chort_run_anim_f1 448 273 16 23
chort_run_anim_f2 464 273 16 23
chort_run_anim_f3 480 273 16 23
column 80 80 16 48
column_wall 96 80 16 48
wall_fountain_mid_blue_anim_f0 64 48 16 16
wall_fountain_mid_blue_anim_f1 80 48 16 16
wall_fountain_mid_blue_anim_f2 96 48 16 16
wall_fountain_mid_red_anim_f0 64 16 16 16
wall_fountain_mid_red_anim_f1 80 16 16 16
wall_fountain_mid_red_anim_f2 96 16 16 16
wall_fountain_basin_red_anim_f0 64 32 16 16
wall_fountain_basin_red_anim_f1 80 32 16 16
wall_fountain_basin_red_anim_f2 96 32 16 16
wall_fountain_basin_blue_anim_f0 64 64 16 16
wall_fountain_basin_blue_anim_f1 80 64 16 16
wall_fountain_basin_blue_anim_f2 96 64 16 16
wall_goo_base 64 96 16 16
wall_goo 64 80 16 16
wall_hole_1 48 32 16 16
wall_hole_2 48 48 16 16
wall_banner_blue 32 32 16 16
wall_banner_red 16 32 16 16
wall_banner_green 16 48 16 16
wall_banner_yellow 32 48 16 16
floor_ladder 48 96 16 16
floor_spikes_anim_f0 16 192 16 16
floor_spikes_anim_f1 32 192 16 16
floor_spikes_anim_f2 48 192 16 16
floor_spikes_anim_f3 64 192 16 16
hole 96 144 16 16
floor_stairs 80 192 16 16
floor_1 16 64 16 16
floor_2 32 64 16 16
floor_3 48 64 16 16
floor_4 16 80 16 16
floor_5 32 80 16 16
floor_6 48 80 16 16
floor_7 16 96 16 16
floor_8 32 96 16 16
wall_left 16 16 16 16
wall_mid 32 16 16 16
wall_right 48 16 16 16
wall_top_left 16 0 16 16
wall_top_mid 32 0 16 16
wall_top_right 48 0 16 16
lizard_m_idle_anim_f0 128 228 16 28
lizard_m_idle_anim_f1 144 228 16 28
lizard_m_idle_anim_f2 160 228 16 28
lizard_m_idle_anim_f3 176 228 16 28
lizard_m_run_anim_f0 192 228 16 28
lizard_m_run_anim_f1 208 228 16 28
lizard_m_run_anim_f2 224 228 16 28
lizard_m_run_anim_f3 240 228 16 28
lizard_m_hit_anim_f0 256 228 16 28
elf_f_idle_anim_f0 128 4 16 28
elf_f_idle_anim_f1 144 4 16 28
elf_f_idle_anim_f2 160 4 16 28
elf_f_idle_anim_f3 176 4 16 28
elf_f_run_anim_f0 192 4 16 28
elf_f_run_anim_f1 208 4 16 28
elf_f_run_anim_f2 224 4 16 28
elf_f_run_anim_f3 240 4 16 28
elf_f_hit_anim_f0 256 4 16 28
elf_m_idle_anim_f0 128 36 16 28
elf_m_idle_anim_f1 144 36 16 28
elf_m_idle_anim_f2 160 36 16 28
elf_m_idle_anim_f3 176 36 16 28
elf_m_run_anim_f0 192 36 16 28
elf_m_run_anim_f1 208 36 16 28
elf_m_run_anim_f2 224 36 16 28
elf_m_run_anim_f3 240 36 16 28
elf_m_hit_anim_f0 256 36 16 28
button_red_up 16 208 16 16
button_red_down 32 208 16 16
button_blue_up 48 208 16 16
button_blue_down 64 208 16 16
lever_left 80 208 16 16
lever_right 96 208 16 16
doors_frame_left 16 240 16 32
doors_frame_right 64 240 16 32
doors_frame_top 32 224 32 16
doors_leaf_closed 32 240 32 32
doors_leaf_open 80 240 32 32
wall_edge_bottom_left 32 168 16 16
wall_edge_bottom_right 48 168 16 16
wall_edge_mid_left 32 152 16 16
wall_edge_top_left 31 120 16 16
wall_edge_left 32 136 16 16
wall_edge_top_right 48 120 16 16
wall_edge_right 48 136 16 16
wall_edge_mid_right 48 152 16 16
wall_edge_tshape_bottom_right 64 152 16 16
wall_edge_tshape_bottom_left 80 152 16 16
wall_edge_tshape_right 64 168 16 16
wall_edge_tshape_left 80 168 16 16
wall_outer_front_right 16 168 16 16
wall_outer_front_left 0 168 16 16
wall_outer_mid_left 0 152 16 16
wall_outer_top_left 0 136 16 16
wall_outer_top_right 16 136 16 16
wall_outer_mid_right 16 152 16 16
wall_fountain_top_1 64 0 16 16
wall_fountain_top_2 80 0 16 16
wall_fountain_top_3 96 0 16 16
slug_anim_f0 368 369 16 23
slug_anim_f1 384 369 16 23
slug_anim_f2 400 369 16 23
slug_anim_f3 416 369 16 23
tiny_slug_anim_f0 432 376 16 16
tiny_slug_anim_f1 448 376 16 16
tiny_slug_anim_f2 464 376 16 16
tiny_slug_anim_f3 480 376 16 16
  `);

      // draw a frame from atlas by name, bottom-aligned to a grid cell
      function drawFrame(name, gx, gy, scale = SCALE) {
        const f = ASSETS.frames[name];
        const x = offX + gx * TILE, y = offY + gy * TILE;
        if (ASSETS.ready && f) {
          const dw = f.w * scale, dh = f.h * scale;
          const cx = x + TILE / 2, by = y + TILE - 2; // bottom align
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(atlas, f.x, f.y, f.w, f.h, Math.floor(cx - dw / 2), Math.floor(by - dh), Math.floor(dw), Math.floor(dh));
        } else {
          // fallback box
          ctx.fillStyle = '#334';
          ctx.fillRect(x + 3, y + 3, TILE - 6, TILE - 6);
        }
      }

      // ========= audio =========
      const SFX = { ctx: null, muted: false, vol: 0.5, _init() { if (this.ctx) return; const AC = window.AudioContext || window.webkitAudioContext; if (!AC) return; this.ctx = new AC(); }, mute(t) { this.muted = t !== undefined ? !!t : !this.muted; document.getElementById('muteBtn').textContent = this.muted ? '🔈' : '🔊'; }, beep(type = 'ui') { if (this.muted) return; this._init(); if (!this.ctx) return; const ctx = this.ctx; const now = ctx.currentTime; const o = ctx.createOscillator(); const g = ctx.createGain(); o.connect(g); g.connect(ctx.destination); const env = (a, d, s, r) => { g.gain.cancelScheduledValues(now); g.gain.setValueAtTime(0, now); g.gain.linearRampToValueAtTime(this.vol, now + a); g.gain.linearRampToValueAtTime(this.vol * s, now + a + d); g.gain.linearRampToValueAtTime(0.0001, now + a + d + r); }; if (type === 'hit') { o.type = 'square'; o.frequency.setValueAtTime(220, now); o.frequency.exponentialRampToValueAtTime(120, now + 0.1); env(0.005, 0.05, 0.3, 0.08); } if (type === 'cast') { o.type = 'sawtooth'; o.frequency.setValueAtTime(440, now); o.frequency.exponentialRampToValueAtTime(660, now + 0.12); env(0.005, 0.08, 0.2, 0.1); } if (type === 'heal') { o.type = 'triangle'; o.frequency.setValueAtTime(660, now); o.frequency.exponentialRampToValueAtTime(880, now + 0.12); env(0.005, 0.1, 0.5, 0.15); } if (type === 'loot') { o.type = 'triangle'; o.frequency.setValueAtTime(880, now); o.frequency.exponentialRampToValueAtTime(1320, now + 0.14); env(0.005, 0.05, 0.2, 0.1); } if (type === 'boss') { o.type = 'square'; o.frequency.setValueAtTime(160, now); o.frequency.exponentialRampToValueAtTime(120, now + 0.25); env(0.005, 0.12, 0.2, 0.25); } if (type === 'ui') { o.type = 'sine'; o.frequency.setValueAtTime(520, now); env(0.005, 0.03, 0.2, 0.05); } o.start(now); o.stop(now + 0.35); } };

      // ========= effects / HUD helpers =========
      const EFFECTS = { BURN: 'Burn', FREEZE: 'Freeze', SHOCK: 'Shock', POISON: 'Poison', BLEED: 'Bleed', STUN: 'Stun', STEALTH: 'Stealth', HASTE: 'Haste' };
      const FX = { floaters: [], hitFlash: 0, shake: 0, toasts: [] };
      function addFloatText(gx, gy, text, color = '#fff', life = 60) { const x = offX + gx * TILE + TILE / 2 + rand(-6, 6), y = offY + gy * TILE + TILE / 2 + rand(-2, 2); FX.floaters.push({ x, y, vy: -0.6, life, ttl: life, text, color }); }
      function addToast(text, color = '#fff', time = 120) { FX.toasts.push({ text, color, time }); }
      function screenShake(s = 6) { FX.shake = Math.max(FX.shake, s); }
      function addEffect(ent, type, dur = 1, power = 0) { if (!ent.effects) ent.effects = []; const e = ent.effects.find(e => e.type === type); if (e) { e.duration = Math.max(e.duration, dur); e.power = Math.max(e.power, power); } else ent.effects.push({ type: type, duration: dur, power }); }
      function hasEffect(ent, type) { return ent.effects && ent.effects.some(e => e.type === type && e.duration > 0); }
      function consumeEffect(ent, type) { if (!ent.effects) return; const i = ent.effects.findIndex(e => e.type === type && e.duration > 0); if (i >= 0) ent.effects.splice(i, 1); }

      // Start-of-turn processing: don't tick down STEALTH/HASTE here
      function processStartEffects(entity) {
        if (!entity.effects) return;
        const out = [];
        for (const eff of entity.effects) {
          switch (eff.type) {
            case EFFECTS.BURN:
              entity.hp -= eff.power || 4; eff.duration--; addFloatText(entity.x, entity.y, `-${eff.power || 4}🔥`, '#ffb0a0', 40);
              break;
            case EFFECTS.POISON:
              entity.hp -= eff.power || 5; eff.duration--; addFloatText(entity.x, entity.y, `-${eff.power || 5}☠`, '#9cff9c', 40);
              break;
            case EFFECTS.FREEZE:
            case EFFECTS.STUN:
              // decrement but DO NOT decide skip here—caller will check explicitly
              eff.duration--;
              break;
            case EFFECTS.STEALTH:
            case EFFECTS.HASTE:
              // positive buffs last through your action — don't tick here
              break;
            default:
              eff.duration--;
              break;
          }
          if (eff.duration > 0) out.push(eff);
        }
        entity.effects = out;
      }

      // End-of-turn decay for positive buffs that should last through your action
      function tickEndTurnBuffs(entity) {
        if (!entity.effects) return;
        for (const eff of entity.effects) {
          if (eff.type === EFFECTS.STEALTH || eff.type === EFFECTS.HASTE) { eff.duration--; }
        }
        entity.effects = entity.effects.filter(e => e.duration > 0);
      }


      function splashDamage(cx, cy, amt) { for (const e of State.enemies) { if (Math.abs(e.x - cx) + Math.abs(e.y - cy) === 1) { e.hp -= amt; addFloatText(e.x, e.y, `-${amt}`, '#ffd18a', 40); } } }
      function onHitCombos(attacker, target, base, meta) {
        let dmg = base;
        if (hasEffect(target, EFFECTS.FREEZE)) { dmg = Math.round(dmg * 1.5); consumeEffect(target, EFFECTS.FREEZE); if (Math.random() < 0.25) addEffect(target, EFFECTS.STUN, 1); addFloatText(target.x, target.y, 'SHATTER!', '#bde0ff', 40); }
        if (meta.element === 'Shock' && hasEffect(target, EFFECTS.BURN)) { splashDamage(target.x, target.y, 10); addFloatText(target.x, target.y, 'OVERLOAD', '#ffe477', 40); }
        if (hasEffect(attacker, EFFECTS.STEALTH)) { dmg = Math.round(dmg * 1.5); if (State.player === attacker) State.player.pages++; consumeEffect(attacker, EFFECTS.STEALTH); State.extraActions++; addFloatText(attacker.x, attacker.y, 'BACKSTAB!', '#d6b8ff', 45); }
        return dmg;
      }

      // ========= story / stages =========
      const STAGES = [{
        name: 'Crypt of Cinders', floors: 4, story: [
          'You descend into the ember-lit crypt. Ash whispers of a stolen flame.',
          'Charred runes hint at a Warden siphoning life from below.',
          'A survivor speaks: “Break the Warden’s brazier and the dead will rest.”',
          'The air glows. The brazier is near. Prepare yourself.'
        ], boss: { name: 'Ember Warden', theme: 'Flaming', hp: 220, dmg: 18 }
      }];

      // ========= tiles / map =========
      const TILES = { FLOOR: 0, WALL: 1, LAVA: 2, BUSH: 3, BOOK: 4, HEAL: 5, SPIKES: 6 };
      const THEMES = [{ key: 'Ember Vault', tiles: [TILES.LAVA, TILES.SPIKES], wallDensity: 0.08 },
      { key: 'Library', tiles: [TILES.BOOK], wallDensity: 0.10 },
      { key: 'Overgrown Crypt', tiles: [TILES.BUSH], wallDensity: 0.10 },
      { key: 'Sanctum', tiles: [TILES.HEAL], wallDensity: 0.06 },
      { key: 'Catacombs', tiles: [], wallDensity: 0.14 }];
      const Map = { tiles: Array.from({ length: GRID_H }, () => Array.from({ length: GRID_W }, () => TILES.FLOOR)), theme: 'Catacombs' };
      const inBounds = (x, y) => x >= 0 && y >= 0 && x < GRID_W && y < GRID_H;
      function tileAt(x, y) { if (!inBounds(x, y)) return TILES.WALL; const row = Map.tiles[y]; if (!row) return TILES.FLOOR; const t = row[x]; return (t === undefined ? TILES.FLOOR : t); }
      const blocked = (x, y) => tileAt(x, y) === TILES.WALL;
      const hazardous = (x, y) => [TILES.LAVA, TILES.SPIKES].includes(tileAt(x, y));
      const aiPassable = (x, y) => inBounds(x, y) && !blocked(x, y);

      function genRoom() {
        Map.tiles = Array.from({ length: GRID_H }, () => Array.from({ length: GRID_W }, () => TILES.FLOOR));
        const theme = choice(THEMES); Map.theme = theme.key;
        // scatter walls
        for (let i = 0; i < Math.floor(GRID_W * GRID_H * theme.wallDensity); i++) { const x = rand(0, GRID_W - 1), y = rand(0, GRID_H - 1); Map.tiles[y][x] = TILES.WALL; }
        // motif
        const motif = choice(['pillars', 'cross', 'ring', 'lanes']);
        if (motif === 'pillars') { for (let y = 1; y < GRID_H; y += 2) for (let x = 1; x < GRID_W; x += 2) if (Math.random() < 0.5) Map.tiles[y][x] = TILES.WALL; }
        else if (motif === 'cross') { for (let x = 2; x < GRID_W - 2; x++) Map.tiles[Math.floor(GRID_H / 2)][x] = TILES.WALL; for (let y = 1; y < GRID_H - 1; y++) Map.tiles[y][Math.floor(GRID_W / 2)] = TILES.WALL; }
        else if (motif === 'ring') { for (let x = 1; x < GRID_W - 1; x++) { Map.tiles[1][x] = TILES.WALL; Map.tiles[GRID_H - 2][x] = TILES.WALL; } for (let y = 1; y < GRID_H - 1; y++) { Map.tiles[y][1] = TILES.WALL; Map.tiles[y][GRID_W - 2] = TILES.WALL; } }
        else if (motif === 'lanes') { for (let y = 0; y < GRID_H; y++) if (y % 2 === 0) for (let x = 0; x < GRID_W; x++) if (Math.random() < 0.25) Map.tiles[y][x] = TILES.WALL; }

        // theme specials
        const empties = []; for (let y = 0; y < GRID_H; y++) for (let x = 0; x < GRID_W; x++) if (Map.tiles[y][x] === TILES.FLOOR) empties.push([x, y]);
        empties.sort(() => Math.random() - 0.5); const count = Math.min(6, Math.floor(empties.length * 0.12));
        for (let i = 0; i < count; i++) { const [x, y] = empties[i]; const t = choice(theme.tiles); if (t !== undefined) Map.tiles[y][x] = t; }

        // clear spawns
        Map.tiles[Math.floor(GRID_H / 2)][1] = TILES.FLOOR;
        Map.tiles[Math.floor(GRID_H / 2)][GRID_W - 2] = TILES.FLOOR;
      }

      function applyTileOnEnter(entity) {
        const t = tileAt(entity.x, entity.y);
        if (t === TILES.BUSH) {
          const bonus = (entity === State.player ? (State.player.armorMods?.stealthPlus || 0) : 0);
          addEffect(entity, EFFECTS.STEALTH, 2 + bonus); // was 1; now persists past end-turn decay
          addFloatText(entity.x, entity.y, 'Hiding', '#9ad5ff', 40);
        }

        if (t === TILES.BOOK && entity === State.player) { State.player.pages++; addFloatText(entity.x, entity.y, '+Page', '#c8b8ff', 40); SFX.beep('loot'); }
        if (t === TILES.HEAL) { const amt = 5; entity.hp = clamp(entity.hp + amt, 0, entity.maxHp || entity.hp + amt); addFloatText(entity.x, entity.y, `+${amt}`, '#7cf59a', 40); }
        if (t === TILES.LAVA) { addEffect(entity, EFFECTS.BURN, 2, 4); }
        if (t === TILES.SPIKES) { entity.hp -= 4; addFloatText(entity.x, entity.y, '-4', '#f5b5b5', 40); }
      }

      // ========= state =========
      const State = {
        roomType: 'BATTLE', gold: 0,
        player: { x: 1, y: 1, hp: 100, maxHp: 100, abilities: [], shields: 0, effects: [], pages: 0, class: '-', armor: null, armorMods: {}, talents: {}, spriteSet: null, movingTicks: 0 },
        enemies: [], turn: 'PLAYER', selection: null,
        floor: 1, stage: 0, stageFloor: 1, storyIndex: 0,
        extraActions: 0,
      };

      // ========= classes / talents =========
      const CLASSES = {
        Wizard: {
          desc: 'Spells +1 range. Elements last longer.', onMakeAbility: (ab) => { if (ab.type === 'attack') ab.range = Math.min(4, (ab.range || 1) + 1); }, spriteSet: 'wizzard_m',
          talents: [{ key: 'ArcaneBattery', label: 'Arcane Battery — every 3rd spell refunds cooldown', apply: p => p.talents.ArcaneBattery = true },
          { key: 'Glacier', label: 'Glacier — Freeze lasts +1', apply: p => p.talents.Glacier = true },
          { key: 'Conduction', label: 'Conduction — Shocked enemies take +25% dmg', apply: p => p.talents.Conduction = true }]
        },
        Rogue: {
          desc: 'End turn away from enemies to gain Stealth. Attacking from Stealth grants a Page.', spriteSet: 'elf_m',
          passiveEndTurn: () => { const adj = State.enemies.some(e => Math.abs(e.x - State.player.x) + Math.abs(e.y - State.player.y) === 1); if (!adj) { addEffect(State.player, EFFECTS.STEALTH, 1 + (State.player.armorMods?.stealthPlus || 0)); addFloatText(State.player.x, State.player.y, 'STEALTH', '#9ad5ff', 45); } },
          talents: [{ key: 'Flurry', label: 'Flurry — First attack each battle hits twice', apply: p => p.talents.Flurry = true },
          { key: 'ShadowScholar', label: 'Shadow Scholar — End turns in Stealth: +1 Page', apply: p => p.talents.ShadowScholar = true },
          { key: 'Expose', label: 'Expose — Bleeding enemies take +30% dmg', apply: p => p.talents.Expose = true }]
        },
        Fighter: {
          desc: '+20 max HP. On kill gain Haste (extra action).', onStart: p => { p.maxHp += 20; p.hp = p.maxHp; }, spriteSet: 'knight_m',
          passiveOnKill: () => { State.extraActions++; addFloatText(State.player.x, State.player.y, 'HASTE!', '#aef5a9', 50); },
          talents: [{ key: 'Riposte', label: 'Riposte — 25% to counter 6 dmg when hit', apply: p => p.talents.Riposte = true },
          { key: 'BrutalStrikes', label: 'Brutal Strikes — +20% attack dmg', apply: p => p.talents.BrutalStrikes = true },
          { key: 'Bulwark', label: 'Bulwark — Start each battle with 15 Shield', apply: p => p.talents.Bulwark = true }]
        },
        Cleric: {
          desc: 'Heals grant 50% as Shield and cleanse 1 debuff.', spriteSet: 'doc',
          passiveOnHeal: (amt) => { State.player.shields += Math.floor(amt * 0.5); cleanseOne(State.player); addFloatText(State.player.x, State.player.y, '+Shield', '#c9ffe5', 40); },
          talents: [{ key: 'Sanctify', label: 'Sanctify — Heals +20%; purge enemy buffs', apply: p => p.talents.Sanctify = true },
          { key: 'Aegis', label: 'Aegis — Begin each floor with 10 Shield', apply: p => p.talents.Aegis = true },
          { key: 'Mercy', label: 'Mercy — 20% at turn start: -1 to all CDs', apply: p => p.talents.Mercy = true }]
        }
      };
      function cleanseOne(ent) { if (!ent.effects) return; const bad = [EFFECTS.BURN, EFFECTS.POISON, EFFECTS.BLEED, EFFECTS.SHOCK, EFFECTS.FREEZE, EFFECTS.STUN]; const i = ent.effects.findIndex(e => bad.includes(e.type)); if (i >= 0) ent.effects.splice(i, 1); }

      // ========= abilities (unchanged) =========
      const RARITY = [{ key: 'Common', color: '#c8d0e0', weight: 40, mult: 1 }, { key: 'Uncommon', color: '#7cf59a', weight: 30, mult: 1.2 }, { key: 'Rare', color: '#8ad1ff', weight: 18, mult: 1.45 }, { key: 'Epic', color: '#b189ff', weight: 9, mult: 1.8 }, { key: 'Legendary', color: '#ffbf4f', weight: 3, mult: 2.3 }];
      const weightedPick = () => { const tot = RARITY.reduce((a, r) => a + r.weight, 0); let r = Math.random() * tot; for (const it of RARITY) { if ((r -= it.weight) <= 0) return it; } return RARITY[0]; };
      const PREFIX = ['Rusty', 'Fine', 'Cruel', 'Heroic', 'Mystic', 'Ancient', 'Gilded', 'Doomed', 'Serrated', 'Blessed'];
      const ELEMENT = ['', 'Flaming', 'Frost', 'Shock', 'Venom', 'Holy', 'Shadow'];
      const BASE = [{ key: 'Slash', type: 'attack' }, { key: 'Bolt', type: 'attack' }, { key: 'Blast', type: 'attack' }, { key: 'Stab', type: 'attack' }, { key: 'Heal', type: 'heal' }, { key: 'Shield', type: 'shield' }, { key: 'Blink', type: 'move' }, { key: 'Hide', type: 'stealth' }, { key: 'Tome', type: 'tome' }];
      function makeAbility() {
        const rar = weightedPick(); const pre = choice(PREFIX); const ele = choice(ELEMENT); const base = choice(BASE); const mult = rar.mult;
        let dmg = 0, heal = 0, shield = 0, range = 1, cd = 0, desc = '', hits = 1, type = base.type, element = null;
        if (type === 'attack') { dmg = Math.round(choice([7, 9, 11, 13, 15]) * mult); range = choice([1, 2, 3]); cd = choice([0, 1, 2]); hits = Math.random() < 0.15 ? 2 : 1; element = ele || null; desc = `Deal ${dmg}${hits > 1 ? ` x${hits}` : ''} at range ${range}${element ? ` (${element})` : ''}.`; }
        if (type === 'heal') { heal = Math.round(choice([10, 14, 18, 22]) * mult); cd = choice([1, 2]); desc = 'Restore ' + heal + ' HP. (Cleric: Shield & cleanse)'; }
        if (type === 'shield') { shield = Math.round(choice([8, 12, 16, 20]) * mult); cd = choice([2, 3]); desc = `Gain ${shield} Shield for 1 room.`; }
        if (type === 'move') { range = choice([2, 3]); cd = choice([1, 2]); desc = `Teleport within ${range} tiles.`; }
        if (type === 'stealth') { cd = 2; range = 0; desc = 'Enter Stealth for 1 turn.'; }
        if (type === 'tome') { cd = 1; range = 0; desc = 'Spend up to 2 Pages: +1 hit to next attack per Page.'; }
        const name = [pre, ele, base.key].filter(Boolean).join(' ');
        const ab = { name, rarity: rar.key, color: rar.color, type, dmg, heal, shield, range, cd, cdLeft: 0, desc, hits, element };
        const c = State.player.class && CLASSES[State.player.class]; if (c && c.onMakeAbility) c.onMakeAbility(ab);
        return ab;
      }
      const newAbilitySet = () => Array.from({ length: 4 }, () => makeAbility());

      // ========= armor =========
      const ARMOR_POOL = [{ name: 'Leather of Shadows', desc: '+1 Stealth duration; attacks from Stealth +10%.', apply: p => { p.armorMods = { stealthPlus: 1, stealthDmg: 1.10 }; } },
      { name: 'Frostplate', desc: 'Attacks inflict brief Freeze (1).', apply: p => { p.armorMods = { onHitFreeze: 1 }; } },
      { name: 'Storm Mail', desc: 'Shock duration +1; Overload splash +5 dmg.', apply: p => { p.armorMods = { shockPlus: 1, overloadPlus: 5 }; } },
      { name: 'Pyromancer Robe', desc: 'Burn ticks +2.', apply: p => { p.armorMods = { burnPlus: 2 }; } },
      { name: "Knight's Bulwark", desc: 'Start battle with +15 Shield.', apply: p => { p.armorMods = { startShield: 15 }; } }];
      function equipArmor(a) { State.player.armor = a; a.apply(State.player); updateHUD(); addToast(`Equipped: ${a.name}`, '#ffd6a6'); SFX.beep('ui'); }

      // ========= enemies / sprites =========
      // pick small enemy sprite sets
      const ENEMY_SETS = [
        { key: 'goblin', idle: 'goblin_idle_anim_f', run: 'goblin_run_anim_f', frames: 4, w: 16, h: 16 },
        { key: 'skelet', idle: 'skelet_idle_anim_f', run: 'skelet_run_anim_f', frames: 4, w: 16, h: 16 },
        { key: 'orc', idle: 'orc_warrior_idle_anim_f', run: 'orc_warrior_run_anim_f', frames: 4, w: 16, h: 23 },
        { key: 'imp', idle: 'imp_idle_anim_f', run: 'imp_run_anim_f', frames: 4, w: 16, h: 16 },
        { key: 'wogol', idle: 'wogol_idle_anim_f', run: 'wogol_run_anim_f', frames: 4, w: 16, h: 23 },
      ];
      const BOSS_SET = { idle: 'big_demon_idle_anim_f', run: 'big_demon_run_anim_f', frames: 4, w: 32, h: 36 };

      function spriteSetForClass(clazz) {
        if (clazz === 'Wizard') return { idle: 'wizzard_m_idle_anim_f', run: 'wizzard_m_run_anim_f', frames: 4, w: 16, h: 28 };
        if (clazz === 'Rogue') return { idle: 'elf_m_idle_anim_f', run: 'elf_m_run_anim_f', frames: 4, w: 16, h: 28 };
        if (clazz === 'Fighter') return { idle: 'knight_m_idle_anim_f', run: 'knight_m_run_anim_f', frames: 4, w: 16, h: 28 };
        if (clazz === 'Cleric') return { idle: 'doc_idle_anim_f', run: 'doc_run_anim_f', frames: 4, w: 16, h: 23 };
        return { idle: 'wizzard_m_idle_anim_f', run: 'wizzard_m_run_anim_f', frames: 4, w: 16, h: 28 };
      }

      function spawnEnemies() {
        const count = clamp(1 + Math.floor(State.floor / 2), 1, 4), enemies = [];
        let placed = 0;
        while (placed < count) {
          const x = GRID_W - 2 - rand(0, 2), y = rand(1, GRID_H - 2); if (!blocked(x, y)) {
            const set = choice(ENEMY_SETS);
            enemies.push({ x, y, hp: 30 + 12 * State.floor, dmg: 8 + 2 * State.floor, effects: [], set, movingTicks: 0 });
            placed++;
          }
        }
        return enemies;
      }
      function spawnBoss() {
        const pos = { x: GRID_W - 3, y: Math.floor(GRID_H / 2) }; if (blocked(pos.x, pos.y)) { pos.x = GRID_W - 2; pos.y = 1; }
        const b = STAGES[State.stage].boss;
        return [{ ...pos, hp: b.hp, dmg: b.dmg, effects: [], isBoss: true, name: b.name, theme: b.theme, set: BOSS_SET, movingTicks: 0 }];
      }

      // pathfinding
      const DIRS = [[1, 0], [-1, 0], [0, 1], [0, -1]];
      function nextStepTowards(e, tx, ty) {
        if (Math.abs(e.x - tx) + Math.abs(e.y - ty) === 1) return { x: e.x, y: e.y };
        const q = [], prev = Array.from({ length: GRID_H }, () => Array.from({ length: GRID_W }, () => null));
        q.push([e.x, e.y]); prev[e.y][e.x] = [e.x, e.y];
        while (q.length) {
          const [cx, cy] = q.shift();
          for (const [dx, dy] of DIRS) {
            const nx = cx + dx, ny = cy + dy; if (!inBounds(nx, ny)) continue; if (prev[ny][nx]) continue; if (!aiPassable(nx, ny)) continue;
            if (State.enemies.some(o => o !== e && o.x === nx && o.y === ny)) continue;
            if (hazardous(nx, ny)) continue;
            prev[ny][nx] = [cx, cy];
            if (nx === tx && ny === ty) {
              let qx = cx, qy = cy;
              while (prev[qy][qx] && !(prev[qy][qx][0] === e.x && prev[qy][qx][1] === e.y)) { const p = prev[qy][qx]; qx = p[0]; qy = p[1]; }
              return { x: qx, y: qy };
            }
            q.push([nx, ny]);
          }
        }
        let best = { x: e.x, y: e.y, score: 9999 };
        for (const [dx, dy] of DIRS) { const nx = e.x + dx, ny = e.y + dy; if (!aiPassable(nx, ny)) continue; if (State.enemies.some(o => o !== e && o.x === nx && o.y === ny)) continue; let s = Math.abs(nx - tx) + Math.abs(ny - ty); if (hazardous(nx, ny)) s += 3; if (s < best.score) { best = { x: nx, y: ny, score: s }; } }
        return { x: best.x, y: best.y };
      }

      // ========= flow =========
      const RoomTypes = ['BATTLE', 'STORY', 'SHOP', 'HEAL', 'BOSS'];
      function nextRoom() {
        State._lootShown = false;

        State.selection = null; State.turn = 'PLAYER'; State.extraActions = 0;
        const stage = STAGES[State.stage];
        const isBossNow = (State.stageFloor > stage.floors);
        if (isBossNow) { State.roomType = 'BOSS'; genRoom(); State.player.x = 1; State.player.y = Math.floor(GRID_H / 2); State.enemies = spawnBoss(); addToast(`Boss: ${stage.boss.name}`, '#ff7ad6', 180); SFX.beep('boss'); }
        else {
          const weights = { BATTLE: 55, STORY: 15, SHOP: 15, HEAL: 15 }; const pool = []; for (const k of ['BATTLE', 'STORY', 'SHOP', 'HEAL']) for (let i = 0; i < weights[k]; i++) pool.push(k);
          State.roomType = choice(pool);
          if (State.roomType === 'BATTLE') { genRoom(); State.player.x = 1; State.player.y = Math.floor(GRID_H / 2); State.enemies = spawnEnemies(); }
          else { State.enemies = []; genRoom(); openRoomModal(); }
        }
        if (State.roomType === 'BATTLE' || State.roomType === 'BOSS') {
          if (State.player.armorMods?.startShield) State.player.shields += State.player.armorMods.startShield;
          if (State.player.class === 'Cleric' && State.player.talents.Aegis) State.player.shields += 10;
        }
        updateHUD();
      }

      function updateHUD() {
        const stage = STAGES[State.stage];
        document.getElementById('roomType').textContent = State.roomType + ` (F${State.floor})`;
        document.getElementById('roomTheme').textContent = (State.roomType === 'BATTLE' || State.roomType === 'BOSS') ? `• ${Map.theme}` : '';
        document.getElementById('gold').textContent = State.gold;
        document.getElementById('clazz').textContent = State.player.class;
        document.getElementById('pages').textContent = State.player.pages;
        document.getElementById('armorName').textContent = State.player.armor ? State.player.armor.name : 'None';
        document.getElementById('hpFill').style.width = clamp(Math.round((State.player.hp / State.player.maxHp) * 100), 0, 100) + '%';
        const progress = Math.min(100, Math.floor((Math.min(State.stageFloor, stage.floors) / stage.floors) * 100));
        document.getElementById('stageProg').style.width = progress + '%';
        document.getElementById('stageLabel').textContent = `${stage.name} ${Math.min(State.stageFloor, stage.floors)}/${stage.floors}`;
      }

      // ========= modal ui =========
      const modal = document.getElementById('modal'), modalTitle = document.getElementById('modalTitle'), modalContent = document.getElementById('modalContent'), modalFooter = document.getElementById('modalFooter');
      const showModal = () => modal.classList.add('show'); const hideModal = () => { modal.classList.remove('show'); modalContent.innerHTML = ''; modalFooter.innerHTML = ''; };

      function openLoadoutModal() {
        modalTitle.textContent = 'Loadout'; modalContent.innerHTML = ''; modalFooter.innerHTML = '';
        const wrap = document.createElement('div'); const section = (title, el) => { const h = document.createElement('h3'); h.textContent = title; wrap.appendChild(h); wrap.appendChild(el); };
        const c = document.createElement('div'); c.className = 'choice'; c.innerHTML = `<div class="title">Class</div><div class="row">${State.player.class} — ${CLASSES[State.player.class]?.desc || ''}</div>`;
        const a = document.createElement('div'); a.className = 'choice'; a.innerHTML = `<div class="title">Armor</div><div class="row">${State.player.armor ? `<b>${State.player.armor.name}</b> — ${State.player.armor.desc}` : 'None'}</div>`;
        const tWrap = document.createElement('div'); tWrap.className = 'choices'; const learned = Object.entries(State.player.talents).filter(([k, v]) => v);
        if (!learned.length) { const d = document.createElement('div'); d.className = 'choice'; d.innerHTML = '<div class="row">No talents learned yet.</div>'; tWrap.appendChild(d); }
        else learned.forEach(([key]) => { const def = CLASSES[State.player.class]?.talents.find(t => t.key === key); const d = document.createElement('div'); d.className = 'choice'; d.innerHTML = `<div class='title'>${def?.label || key}</div>`; tWrap.appendChild(d); });
        const g = document.createElement('div'); g.className = 'choice'; g.innerHTML = `<div class='title'>Legend</div><div class='row'>🔥 Burn • ❄ Freeze • ⚡ Shock • ☠ Poison • 🩸 Bleed • 🛡 Shield • Page: empowers Tome</div>`;
        section('Class', c); section('Armor', a); section('Talents', tWrap); section('Legend', g); modalContent.appendChild(wrap);
        const close = document.createElement('button'); close.textContent = 'Close'; close.onclick = hideModal; modalFooter.appendChild(close); showModal();
      }

      function openRoomModal() {
        modalTitle.textContent = State.roomType; modalContent.innerHTML = ''; modalFooter.innerHTML = '';
        if (State.roomType === 'STORY') {
          const stage = STAGES[State.stage]; const line = stage.story[Math.min(State.storyIndex, stage.story.length - 1)];
          modalContent.innerHTML = `<p>${line}</p>`;
          const cont = document.createElement('button'); cont.textContent = 'Continue'; cont.onclick = () => { State.storyIndex++; hideModal(); nextRoom(); SFX.beep('ui'); };
          modalFooter.appendChild(cont); showModal();
        } else if (State.roomType === 'SHOP') {
          const offers = [makeAbility(), makeAbility(), makeAbility()], prices = offers.map(() => rand(25, 50));
          const wrap = document.createElement('div'); wrap.className = 'choices';
          offers.forEach((ab, i) => {
            const div = document.createElement('div'); div.className = 'choice'; div.innerHTML = `<div class="title" style="color:${ab.color}">${ab.name} <span class="pill">${ab.rarity}</span></div>
          <div class="row"><span>${ab.desc}</span></div>
          <div class="row"><span class="pill">CD ${ab.cd}</span><span class="pill">Range ${ab.range || 1}</span>${ab.hits > 1 ? `<span class="pill">Hits ${ab.hits}</span>` : ''}</div>
          <div class="row" style="margin-top:6px">Price: <b class="gold">${prices[i]}g</b></div>`; const buy = document.createElement('button'); buy.textContent = 'Buy & replace...'; buy.onclick = () => replaceAbilityFlow(ab, prices[i]); div.appendChild(buy); wrap.appendChild(div);
          });
          const armor = choice(ARMOR_POOL); const ar = document.createElement('div'); ar.className = 'choice'; ar.innerHTML = `<div class="title">${armor.name}</div><div class="row">${armor.desc}</div><div class='row' style='margin-top:6px'>Price: <b class='gold'>60g</b></div>`;
          const buyA = document.createElement('button'); buyA.textContent = 'Buy armor'; buyA.onclick = () => { if (State.gold < 60) { buyA.textContent = 'Not enough gold'; return; } State.gold -= 60; equipArmor(armor); updateHUD(); hideModal(); nextRoom(); };
          ar.appendChild(buyA); wrap.appendChild(ar); modalContent.appendChild(wrap);
          const skip = document.createElement('button'); skip.textContent = 'Leave shop'; skip.onclick = () => { hideModal(); nextRoom(); SFX.beep('ui'); }; modalFooter.appendChild(skip); showModal();
        } else if (State.roomType === 'HEAL') {
          const amt = Math.round(State.player.maxHp * 0.4);
          modalContent.innerHTML = `<p>You discover a tranquil fountain. Restore <b>${amt} HP</b>?</p>`;
          const yes = document.createElement('button'); yes.textContent = 'Drink'; yes.onclick = () => { State.player.hp = clamp(State.player.hp + amt, 0, State.player.maxHp); updateHUD(); hideModal(); nextRoom(); SFX.beep('heal'); };
          const no = document.createElement('button'); no.textContent = 'Move on'; no.onclick = () => { hideModal(); nextRoom(); SFX.beep('ui'); };
          modalFooter.appendChild(yes); modalFooter.appendChild(no); showModal();
        }
      }

      function replaceAbilityFlow(newAb, price) {
        const grid = document.createElement('div'); grid.className = 'choices';
        State.player.abilities.forEach((cur, i) => {
          const d = document.createElement('div'); d.className = 'choice'; d.innerHTML = `<div class="title">Slot ${i + 1}</div><div class="row"><span style="color:${cur.color}">${cur.name}</span></div><div class="row"><span>${cur.desc}</span></div>`;
          const b = document.createElement('button'); b.textContent = price ? `Replace with ${newAb.name} (${price}g)` : `Replace with ${newAb.name}`; b.onclick = () => { if (price && State.gold < price) { b.textContent = 'Not enough gold'; return; } if (price) State.gold -= price; State.player.abilities[i] = newAb; renderAbilityButtons(); updateHUD(); hideModal(); nextRoom(); SFX.beep('ui'); };
          d.appendChild(b); grid.appendChild(d);
        });
        modalContent.innerHTML = ''; modalContent.appendChild(grid);
      }

      function openLootModal() {
        modalTitle.textContent = State.roomType === 'BOSS' ? 'Boss Defeated! Choose rewards' : 'Victory! Choose rewards';
        modalContent.innerHTML = ''; modalFooter.innerHTML = '';
        const root = document.createElement('div');
        const loot = [makeAbility(), makeAbility(), makeAbility()], abWrap = document.createElement('div'); abWrap.className = 'choices';
        loot.forEach(ab => { const d = document.createElement('div'); d.className = 'choice'; d.innerHTML = `<div class="title" style="color:${ab.color}">${ab.name} <span class="pill">${ab.rarity}</span></div><div class="row"><span>${ab.desc}</span></div><div class="row"><span class="pill">CD ${ab.cd}</span><span class="pill">Range ${ab.range || 1}</span>${ab.hits > 1 ? `<span class="pill">Hits ${ab.hits}</span>` : ''}</div>`; const b = document.createElement('button'); b.textContent = 'Take & replace...'; b.onclick = () => { replaceAbilityFlow(ab, 0); SFX.beep('loot'); }; d.appendChild(b); abWrap.appendChild(d); });
        root.appendChild(document.createElement('h3')).textContent = 'Abilities'; root.appendChild(abWrap);

        const roll = Math.random();
        if (roll < 0.5) {
          const picks = [choice(ARMOR_POOL), choice(ARMOR_POOL)], aw = document.createElement('div'); aw.className = 'choices';
          picks.forEach(a => { const d = document.createElement('div'); d.className = 'choice'; d.innerHTML = `<div class='title'>${a.name}</div><div class='row'>${a.desc}</div>`; const b = document.createElement('button'); b.textContent = 'Equip'; b.onclick = () => { equipArmor(a); hideModal(); afterRewards(); }; d.appendChild(b); aw.appendChild(d); });
          root.appendChild(document.createElement('h3')).textContent = 'Bonus: Armor'; root.appendChild(aw);
        } else {
          const clazz = CLASSES[State.player.class]; if (clazz) { const pool = [...clazz.talents]; const picks = [pool.splice(rand(0, pool.length - 1), 1)[0], pool.splice(rand(0, Math.max(0, pool.length - 1)), 1)[0]].filter(Boolean); if (picks.length) { const tw = document.createElement('div'); tw.className = 'choices'; picks.forEach(t => { const d = document.createElement('div'); d.className = 'choice'; d.innerHTML = `<div class='title'>${t.label}</div>`; const b = document.createElement('button'); b.textContent = 'Learn'; b.onclick = () => { t.apply(State.player); hideModal(); afterRewards(); }; d.appendChild(b); tw.appendChild(d); }); root.appendChild(document.createElement('h3')).textContent = 'Bonus: Talent'; root.appendChild(tw); } }
        }
        modalContent.appendChild(root);
        const skip = document.createElement('button'); skip.textContent = 'Skip (keep current)'; skip.onclick = () => { hideModal(); afterRewards(); };
        modalFooter.appendChild(skip); showModal();
      }
      function afterRewards() { const wasBoss = (State.roomType === 'BOSS'); if (wasBoss) { modalTitle.textContent = 'Run Cleared!'; modalContent.innerHTML = `<p>You extinguished the <b>${STAGES[State.stage].boss.name}</b> and calmed the <b>${STAGES[State.stage].name}</b>.</p><p>Floor reached: <b>${State.floor}</b> • Gold: <span class='gold'><b>${State.gold}</b></span></p>`; modalFooter.innerHTML = ''; const b = document.createElement('button'); b.textContent = 'Start a new run'; b.onclick = () => { startRun(); hideModal(); }; modalFooter.appendChild(b); showModal(); return; } State.floor++; State.stageFloor++; nextRoom(); }
      function gameOver() { modalTitle.textContent = 'Game Over'; modalContent.innerHTML = `<p>You fell on <b>Floor ${State.floor}</b> with <span class="gold"><b>${State.gold} gold</b></span>.</p>`; modalFooter.innerHTML = ''; const b = document.createElement('button'); b.textContent = 'Restart run'; b.onclick = () => { startRun(); hideModal(); }; modalFooter.appendChild(b); showModal(); }

      // ========= input =========
      function dirMove(dx, dy) {
        if (State.roomType !== 'BATTLE' && State.roomType !== 'BOSS') return; if (State.turn !== 'PLAYER') return;
        if (hasEffect(State.player, EFFECTS.FREEZE) || hasEffect(State.player, EFFECTS.STUN)) return;
        const nx = clamp(State.player.x + dx, 0, GRID_W - 1), ny = clamp(State.player.y + dy, 0, GRID_H - 1);
        if (blocked(nx, ny)) return; if (State.enemies.some(e => e.x === nx && e.y === ny)) return;
        State.player.x = nx; State.player.y = ny; State.player.movingTicks = 6; applyTileOnEnter(State.player);
        if (hasEffect(State.player, EFFECTS.BLEED)) { State.player.hp -= 6; addFloatText(State.player.x, State.player.y, '-6', '#f59999', 40); }
        endPlayerTurn();
      }
      document.querySelector('.dpad').addEventListener('touchstart', e => { const t = e.target.closest('button'); if (!t) return; const dir = t.getAttribute('data-dir'); if (dir === 'up') dirMove(0, -1); if (dir === 'down') dirMove(0, 1); if (dir === 'left') dirMove(-1, 0); if (dir === 'right') dirMove(1, 0); }, { passive: true });
      document.querySelector('.dpad').addEventListener('click', e => { const t = e.target.closest('button'); if (!t) return; const dir = t.getAttribute('data-dir'); if (dir === 'up') dirMove(0, -1); if (dir === 'down') dirMove(0, 1); if (dir === 'left') dirMove(-1, 0); if (dir === 'right') dirMove(1, 0); });
      document.getElementById('loadoutBtn').onclick = openLoadoutModal;
      document.getElementById('restartBtn').onclick = () => startRun();
      document.getElementById('muteBtn').onclick = () => { SFX.mute(); SFX.beep('ui'); };

      const abilitiesEl = document.getElementById('abilities');
      // Use hover only on devices that actually support it
      const SUPPORTS_HOVER = window.matchMedia && window.matchMedia('(hover: hover)').matches;
      const abilityInfoEl = document.getElementById('abilityInfo');
      const ABILITY_HINT = 'Click/tap an ability, then tap a tile. Hover to see details here.';

      function setAbilityInfoFromSelection() {
        if (State.selection && State.selection.ab) {
          abilityInfoEl.textContent = `${State.selection.ab.name}: ${State.selection.ab.desc}`;
        } else {
          abilityInfoEl.textContent = ABILITY_HINT;
        }
      }

      function renderAbilityButtons() {
        abilitiesEl.innerHTML = '';
        State.player.abilities.forEach((ab, idx) => {
          const b = document.createElement('button');
          b.innerHTML = `
      <div style="font-size:12px;opacity:.8">Slot ${idx + 1} • <span style="color:${ab.color}">${ab.rarity}</span></div>
      <div>${ab.name}</div>
      <div class="smallRow">
        <span class="pill">CD ${ab.cdLeft || 0}/${ab.cd}</span>
        ${ab.range ? `<span class="pill">R${ab.range}</span>` : ``}
        ${ab.hits > 1 ? `<span class="pill">x${ab.hits}</span>` : ``}
        ${ab.element ? `<span class="pill">${ab.element}</span>` : ``}
      </div>`;
          b.title = `${ab.name} — ${ab.desc}`;
          if (ab.cdLeft > 0) b.classList.add('cooldown');

          // Select immediately on pointerdown (prevents DOM-swap/ghost-click issues)
          b.addEventListener('pointerdown', (ev) => {
            ev.preventDefault();
            selectAbility(idx);
            setAbilityInfoFromSelection();
          }, { passive: false });

          // Kill any synthetic click that might still fire on some browsers
          b.addEventListener('click', (e) => e.preventDefault(), { passive: false });

          // Desktop hover → show details in HUD (never a modal)
          if (SUPPORTS_HOVER) {
            b.addEventListener('pointerenter', () => {
              abilityInfoEl.textContent = `${ab.name}: ${ab.desc}`;
            });
            const reset = () => setAbilityInfoFromSelection();
            b.addEventListener('pointerleave', reset);
            b.addEventListener('pointercancel', reset);
          }

          abilitiesEl.appendChild(b);
        });

        setAbilityInfoFromSelection();
      }


      function showAbilityInfo(ab) { modalTitle.textContent = ab.name; modalContent.innerHTML = `<p style='color:${ab.color};font-weight:800'>${ab.rarity}</p><p>${ab.desc}</p>`; modalFooter.innerHTML = ''; const c = document.createElement('button'); c.textContent = 'Close'; c.onclick = hideModal; modalFooter.appendChild(c); showModal(); }

      function selectAbility(idx) {
        const ab = State.player.abilities[idx]; if ((State.roomType !== 'BATTLE' && State.roomType !== 'BOSS') || State.turn !== 'PLAYER') return; if (ab.cdLeft > 0) return;
        document.getElementById('abilityInfo').textContent = `${ab.name}: ${ab.desc}`; State.selection = { idx, ab };
        if (ab.type === 'tome') { const spend = Math.min(2, State.player.pages); if (spend > 0) { State.player.pages -= spend; State.pendingHits = (State.pendingHits || 0) + spend; addFloatText(State.player.x, State.player.y, `+${spend} hit`, '#d0c7ff', 45); SFX.beep('cast'); } ab.cdLeft = ab.cd; State.selection = null; updateHUD(); return; }
        if (ab.type === 'stealth') { addEffect(State.player, EFFECTS.STEALTH, 1 + (State.player.armorMods?.stealthPlus || 0)); addFloatText(State.player.x, State.player.y, 'STEALTH', '#9ad5ff', 45); SFX.beep('cast'); ab.cdLeft = ab.cd; State.selection = null; endPlayerTurn(); }
      }
      // Back-compat: enemyTurn expects { skip } from processEffects()
      // Use the new start-of-turn ticker + explicit FREEZE/STUN check.
      function processEffects(entity) {
        processStartEffects(entity); // applies DOTs and decrements debuffs
        const skip = hasEffect(entity, EFFECTS.FREEZE) || hasEffect(entity, EFFECTS.STUN);
        return { skip };
      }

      // ========= turns =========
      function startPlayerTurn() {
        processStartEffects(State.player);
        if (victoryCheck('turnStart')) return;

        const frozen = hasEffect(State.player, EFFECTS.FREEZE);
        const stunned = hasEffect(State.player, EFFECTS.STUN);
        const skip = frozen || stunned;                // Stealth NEVER causes skip

        if (State.player.class === 'Cleric' && State.player.talents.Mercy && Math.random() < 0.2) {
          State.player.abilities.forEach(a => { if (a.cdLeft > 0) a.cdLeft--; });
          addFloatText(State.player.x, State.player.y, 'Mercy', '#c9ffe5', 40);
        }

        renderAbilityButtons();
        updateHUD();

        if (State.player.hp <= 0) { gameOver(); return; }
        if (skip) { addFloatText(State.player.x, State.player.y, frozen ? 'Frozen' : 'Stunned', '#b0c7ff', 40); endPlayerTurn(true); return; }
      }


      function endPlayerTurn(skipped = false) {
        State.player.abilities.forEach(ab => { if (ab.cdLeft > 0) ab.cdLeft = Math.max(0, ab.cdLeft - 1); });

        // Decay STEALTH/HASTE after you act
        tickEndTurnBuffs(State.player);

        // Rogue passive: apply new Stealth if not adjacent
        if (State.player.class === 'Rogue' && CLASSES.Rogue.passiveEndTurn) CLASSES.Rogue.passiveEndTurn();

        // Shadow Scholar: if you end the turn in Stealth, gain a Page
        if (State.player.class === 'Rogue' && State.player.talents.ShadowScholar && hasEffect(State.player, EFFECTS.STEALTH)) {
          State.player.pages++; addFloatText(State.player.x, State.player.y, '+Page', '#c8b8ff', 40);
        }

        if (!skipped && State.extraActions > 0) { State.extraActions--; startPlayerTurn(); return; }
        State.turn = 'ENEMY'; enemyTurn();
      }

      function enemyTurn() {
        for (const e of [...State.enemies]) {
          const { skip } = processEffects(e); if (e.hp <= 0) continue; if (skip) continue;
          const step = nextStepTowards(e, State.player.x, State.player.y); if (step.x !== e.x || step.y !== e.y) { e.x = step.x; e.y = step.y; e.movingTicks = 6; applyTileOnEnter(e); }
          if (hasEffect(e, EFFECTS.BLEED)) e.hp -= 6;
          if (Math.abs(e.x - State.player.x) + Math.abs(e.y - State.player.y) === 1) {
            let dmg = e.dmg; if (State.player.shields > 0) { const soak = Math.min(State.player.shields, dmg); State.player.shields -= soak; dmg -= soak; }
            if (dmg > 0) { State.player.hp -= dmg; addFloatText(State.player.x, State.player.y, `-${dmg}`, '#ff8a8a', 50); screenShake(8); FX.hitFlash = Math.min(0.3, FX.hitFlash + 0.2); SFX.beep('hit'); if (State.player.class === 'Fighter' && State.player.talents.Riposte && Math.random() < 0.25) { e.hp -= 6; addFloatText(e.x, e.y, '-6 (Riposte)', '#ffe0a5', 40); } }
          }
        }
        State.enemies = State.enemies.filter(e => e.hp > 0);
        if (victoryCheck('enemyTurn')) return;
        updateHUD(); if (State.player.hp <= 0) { gameOver(); return; } State.turn = 'PLAYER'; startPlayerTurn();
      }

      // ========= tap targeting =========
      canvas.addEventListener('click', handleTap);
      canvas.addEventListener('touchstart', e => { const t = e.changedTouches[0]; handleTap({ clientX: t.clientX, clientY: t.clientY }); }, { passive: true });
      function handleTap(ev) {
        if ((State.roomType !== 'BATTLE' && State.roomType !== 'BOSS') || State.turn !== 'PLAYER') return;
        const x = (ev.clientX || 0) * DPR, y = (ev.clientY || 0) * DPR; const gx = Math.floor((x - offX) / TILE), gy = Math.floor((y - offY) / TILE);
        if (gx < 0 || gy < 0 || gx >= GRID_W || gy >= GRID_H) return;
        if (State.selection) {
          const { ab } = State.selection; const dist = Math.abs(gx - State.player.x) + Math.abs(gy - State.player.y);
          if (ab.type === 'attack') {
            if (dist <= ab.range) { const target = State.enemies.find(e => e.x === gx && e.y === gy); if (target) { resolveAttack(State.player, target, ab); if (victoryCheck('attack')) { return; } State.selection = null; endPlayerTurn(); SFX.beep('cast'); } }
          } else if (ab.type === 'heal') {
            if (gx === State.player.x && gy === State.player.y) { let amt = ab.heal; if (State.player.class === 'Cleric' && State.player.talents.Sanctify) amt = Math.round(amt * 1.2); State.player.hp = clamp(State.player.hp + amt, 0, State.player.maxHp); addFloatText(State.player.x, State.player.y, `+${amt}`, '#7cf59a', 50); if (State.player.class === 'Cleric' && CLASSES.Cleric.passiveOnHeal) CLASSES.Cleric.passiveOnHeal(amt); ab.cdLeft = ab.cd; State.selection = null; updateHUD(); endPlayerTurn(); SFX.beep('heal'); }
          } else if (ab.type === 'shield') {
            if (gx === State.player.x && gy === State.player.y) { State.player.shields += ab.shield; addFloatText(State.player.x, State.player.y, `+${ab.shield}🛡`, '#bde7ff', 40); ab.cdLeft = ab.cd; State.selection = null; endPlayerTurn(); SFX.beep('cast'); }
          } else if (ab.type === 'move') {
            if (dist <= ab.range && !State.enemies.some(e => e.x === gx && e.y === gy) && !blocked(gx, gy)) { State.player.x = gx; State.player.y = gy; State.player.movingTicks = 6; applyTileOnEnter(State.player); addFloatText(gx, gy, 'BLINK', '#8ad1ff', 40); ab.cdLeft = ab.cd; State.selection = null; endPlayerTurn(); SFX.beep('cast'); }
          }
        }
      }

      function resolveAttack(attacker, target, ab) {
        let hits = ab.hits + (State.pendingHits || 0); State.pendingHits = 0;
        if (State.player === attacker && State.player.class === 'Rogue' && State.player.talents.Flurry && !State._flurryUsed) { hits++; State._flurryUsed = true; addFloatText(attacker.x, attacker.y, 'FLURRY +1', '#d6b8ff', 45); }
        for (let i = 0; i < hits; i++) {
          let dmg = ab.dmg; if (State.player === attacker && State.player.class === 'Fighter' && State.player.talents.BrutalStrikes) dmg = Math.round(dmg * 1.2); if (State.player === attacker && State.player.talents.Conduction && hasEffect(target, EFFECTS.SHOCK)) dmg = Math.round(dmg * 1.25); if (State.player === attacker && State.player.talents.Expose && hasEffect(target, EFFECTS.BLEED)) dmg = Math.round(dmg * 1.3);
          dmg = onHitCombos(attacker, target, dmg, { element: ab.element }); target.hp -= dmg; addFloatText(target.x, target.y, `-${dmg}`, '#ff8a8a', 50);
          if (ab.element === 'Flaming') addEffect(target, EFFECTS.BURN, 3, (4 + (State.player.armorMods?.burnPlus || 0)));
          if (ab.element === 'Frost') addEffect(target, EFFECTS.FREEZE, 1 + (State.player.talents.Glacier ? 1 : 0));
          if (ab.element === 'Shock') addEffect(target, EFFECTS.SHOCK, 1 + (State.player.armorMods?.shockPlus || 0));
          if (ab.element === 'Venom') addEffect(target, EFFECTS.POISON, 3, 5);
          if (ab.element === 'Shadow') addEffect(target, EFFECTS.BLEED, 3, 0);
          if (State.player === attacker && State.player.class === 'Wizard' && State.player.talents.ArcaneBattery) { State.player._casts = (State.player._casts || 0) + 1; if (State.player._casts % 3 === 0) { ab.cdLeft = 0; addFloatText(attacker.x, attacker.y, 'BATTERY!', '#b6f7ff', 45); } }
          if (ab.element === 'Shock' && hasEffect(target, EFFECTS.BURN) && State.player.armorMods?.overloadPlus) { splashDamage(target.x, target.y, State.player.armorMods.overloadPlus); }
        }
        if (target.hp <= 0 && State.player === attacker && State.player.class === 'Fighter') CLASSES.Fighter.passiveOnKill();
        ab.cdLeft = ab.cd; State.selection = null; State.enemies = State.enemies.filter(e => e.hp > 0); SFX.beep('hit');
      }

      // ========= render =========
      let tick = 0;
      function drawGrid() {
        ctx.save();
        if (FX.shake > 0) { ctx.translate((Math.random() - 0.5) * FX.shake, (Math.random() - 0.5) * FX.shake); FX.shake *= 0.92; if (FX.shake < 0.2) FX.shake = 0; }
        // vignette bg
        const g = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 10, canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) / 1.2);
        g.addColorStop(0, '#101635'); g.addColorStop(1, '#060914'); ctx.fillStyle = g; ctx.fillRect(0, 0, canvas.width, canvas.height);

        // draw tiles (floor + overlays)
        const floorNames = ['floor_1', 'floor_2', 'floor_3', 'floor_4', 'floor_5', 'floor_6', 'floor_7', 'floor_8'];
        const spikeFrames = ['floor_spikes_anim_f0', 'floor_spikes_anim_f1', 'floor_spikes_anim_f2', 'floor_spikes_anim_f3'];
        const spikeName = spikeFrames[Math.floor(tick / 12) % 4];

        for (let y = 0; y < GRID_H; y++) {
          for (let x = 0; x < GRID_W; x++) {
            // base floor
            const base = floorNames[(x + y * 3) % floorNames.length];
            drawFrame(base, x, y, SCALE);

            const t = tileAt(x, y);
            if (t === TILES.WALL) { drawFrame('wall_mid', x, y, SCALE); }
            if (t === TILES.SPIKES) { drawFrame(spikeName, x, y, SCALE); }
            if (t === TILES.LAVA) { // visually: a hole + ember glow
              drawFrame('hole', x, y, SCALE);
              ctx.globalAlpha = 0.25; ctx.fillStyle = '#ff6a00'; ctx.fillRect(offX + x * TILE + 4, offY + y * TILE + 4, TILE - 8, TILE - 8); ctx.globalAlpha = 1;
            }
            if (t === TILES.BOOK) { drawFrame('flask_blue', x, y, SCALE); }
            if (t === TILES.HEAL) { drawFrame('flask_green', x, y, SCALE); }
            if (t === TILES.BUSH) { // stealth puddle
              ctx.globalAlpha = 0.30; ctx.fillStyle = '#0b5530';
              ctx.beginPath(); ctx.arc(offX + x * TILE + TILE / 2, offY + y * TILE + TILE * 0.6, TILE * 0.35, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1;
            }
            // cell outline
            ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1; ctx.strokeRect(offX + x * TILE + 0.5, offY + y * TILE + 0.5, TILE - 1.5, TILE - 1.5);
          }
        }

        // selection highlight
        if (State.selection) {
          const ab = State.selection.ab; ctx.globalAlpha = 0.30; ctx.fillStyle = ab.type === 'attack' ? '#ff6565' : (ab.type === 'move' ? '#8ad1ff' : '#7cf59a');
          for (let y = 0; y < GRID_H; y++) for (let x = 0; x < GRID_W; x++) {
            const dist = Math.abs(x - State.player.x) + Math.abs(y - State.player.y);
            if ((ab.type === 'attack' || ab.type === 'move') && dist <= ab.range && !blocked(x, y)) ctx.fillRect(offX + x * TILE, offY + y * TILE, TILE - 2, TILE - 2);
            if ((ab.type === 'heal' || ab.type === 'shield') && x === State.player.x && y === State.player.y) ctx.fillRect(offX + x * TILE, offY + y * TILE, TILE - 2, TILE - 2);
          }
          ctx.globalAlpha = 1;
        }

        // enemies
        for (const e of State.enemies) {
          const set = e.set;
          const prefix = (e.movingTicks > 0 ? set.run : set.idle);
          const frm = prefix + (Math.floor(tick / 10) % set.frames);
          drawFrame(frm, e.x, e.y);
          e.movingTicks = Math.max(0, e.movingTicks - 1);

          // hp bar
          const baseHp = e.isBoss ? STAGES[State.stage].boss.hp : (30 + 12 * State.floor);
          const pct = clamp(e.hp / baseHp, 0, 1);
          const gx = offX + e.x * TILE + TILE / 2, gy = offY + e.y * TILE + TILE / 2;
          ctx.fillStyle = '#000'; ctx.fillRect(gx - TILE * 0.35, gy - TILE * 0.55, TILE * 0.7, 6);
          ctx.fillStyle = e.isBoss ? '#ff7ad6' : '#ff7a7a'; ctx.fillRect(gx - TILE * 0.35, gy - TILE * 0.55, TILE * 0.7 * pct, 6);
          if (e.isBoss) { ctx.font = `${Math.floor(12 * DPR)}px sans-serif`; ctx.fillStyle = '#ffd6f2'; ctx.textAlign = 'center'; ctx.fillText('👑 ' + (e.name || 'Boss'), gx, gy - TILE * 0.6); }
        }

        // player
        const ps = State.player.spriteSet || spriteSetForClass(State.player.class);
        const pfx = (State.player.movingTicks > 0 ? ps.run : ps.idle);
        const pfrm = pfx + (Math.floor(tick / 10) % ps.frames);
        drawFrame(pfrm, State.player.x, State.player.y);
        State.player.movingTicks = Math.max(0, State.player.movingTicks - 1);
        if (State.player.shields > 0) { const px = offX + State.player.x * TILE + TILE / 2, py = offY + State.player.y * TILE + TILE / 2; ctx.strokeStyle = '#8ad1ff'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(px, py, TILE * 0.42, 0, Math.PI * 2); ctx.stroke(); }
        if (hasEffect(State.player, EFFECTS.STEALTH)) { const px = offX + State.player.x * TILE + TILE / 2, py = offY + State.player.y * TILE + TILE / 2; ctx.globalAlpha = 0.35; ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(px, py, TILE * 0.45, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; ctx.font = `${Math.floor(12 * DPR)}px sans-serif`; ctx.fillStyle = '#9ad5ff'; ctx.textAlign = 'center'; ctx.fillText('STEALTH', px, py - TILE * 0.6); }

        // floating text
        for (const f of FX.floaters) { f.y += f.vy; f.ttl--; const a = Math.max(0, f.ttl / f.life); ctx.globalAlpha = a; ctx.fillStyle = f.color; ctx.font = `${Math.floor(16 * DPR)}px sans-serif`; ctx.textAlign = 'center'; ctx.fillText(f.text, f.x, f.y); ctx.globalAlpha = 1; }
        FX.floaters = FX.floaters.filter(f => f.ttl > 0);

        // turn banner
        ctx.globalAlpha = 0.25; ctx.fillStyle = '#fff'; ctx.font = `${Math.floor(24 * DPR)}px sans-serif`; ctx.textAlign = 'center'; ctx.fillText(State.turn === 'PLAYER' ? 'Your Turn' : 'Enemy Turn', canvas.width / 2, offY - 14); ctx.globalAlpha = 1;

        // toasts
        let ty = 40 * DPR; for (const t of FX.toasts) { ctx.globalAlpha = Math.min(1, t.time / 30); ctx.fillStyle = t.color; ctx.font = `${Math.floor(22 * DPR)}px sans-serif`; ctx.textAlign = 'center'; ctx.fillText(t.text, canvas.width / 2, ty); ctx.globalAlpha = 1; t.time--; ty += 28 * DPR; } FX.toasts = FX.toasts.filter(t => t.time > 0);

        if (FX.hitFlash > 0) { ctx.fillStyle = 'rgba(255,60,60,' + FX.hitFlash + ')'; ctx.fillRect(0, 0, canvas.width, canvas.height); FX.hitFlash = Math.max(0, FX.hitFlash - 0.02); }
        ctx.restore();
        tick++;
      }

      function loop() { drawGrid(); requestAnimationFrame(loop); }

      // ========= run setup =========
      function openClassSelect() {
        modalTitle.textContent = 'Choose Your Class'; modalContent.innerHTML = ''; modalFooter.innerHTML = '';
        const wrap = document.createElement('div'); wrap.className = 'choices';
        Object.entries(CLASSES).forEach(([name, def]) => { const d = document.createElement('div'); d.className = 'choice'; d.innerHTML = `<div class='title'>${name}</div><div class='row'>${def.desc}</div>`; const b = document.createElement('button'); b.textContent = `Become ${name}`; b.onclick = () => { State.player.class = name; State.player.spriteSet = spriteSetForClass(name); if (def.onStart) def.onStart(State.player); State.player.abilities = newAbilitySet(); State._flurryUsed = false; renderAbilityButtons(); updateHUD(); hideModal(); nextRoom(); SFX.beep('ui'); }; d.appendChild(b); wrap.appendChild(d); });
        const legend = document.createElement('div'); legend.className = 'choice'; legend.innerHTML = "<div class='title'>Legend</div><div class='row'>Tap an ability then tap a tile • hover on an ability for details • Puddle = stealth • Blue flask = Page • Green flask = heal • Spikes = trap • Hole = lava</div>";
        wrap.appendChild(legend); modalContent.appendChild(wrap); showModal();
      }

      function startRun() {
        State._lootShown = false;
        State.gold = 0; State.floor = 1; State.stage = 0; State.stageFloor = 1; State.storyIndex = 0; Object.assign(State.player, { hp: 100, maxHp: 100, shields: 0, effects: [], pages: 0, armor: null, armorMods: {}, talents: {}, movingTicks: 0 }); State.pendingHits = 0; State.extraActions = 0; State._flurryUsed = false; renderAbilityButtons(); updateHUD(); openClassSelect(); addToast('A new run begins...', '#cde3ff', 120);
      }


      // ========= self-tests =========
      function runSelfTests() {
        const results = []; const ok = (name, cond) => { results.push({ name, pass: !!cond }); if (!cond) console.error('❌', name); };
        try {
          // tileAt safe
          const keep = Map.tiles; Map.tiles = []; ok('tileAt safe on empty map', typeof tileAt(0, 0) === 'number'); Map.tiles = keep;
          // frames exist
          ok('has floor_1', !!ASSETS.frames['floor_1']);
          ok('has wall_mid', !!ASSETS.frames['wall_mid']);
          ok('has goblin idle', !!ASSETS.frames['goblin_idle_anim_f0']);
          ok('has class wizard idle', !!ASSETS.frames['wizzard_m_idle_anim_f0']);
          ok('has boss frame', !!ASSETS.frames['big_demon_idle_anim_f0']);
          // BFS returns in-bounds
          genRoom(); const e = { x: GRID_W - 2, y: Math.floor(GRID_H / 2), hp: 10, dmg: 1, effects: [] }; const step = nextStepTowards(e, 1, Math.floor(GRID_H / 2)); ok('BFS step in-bounds', step && inBounds(step.x, step.y));
        } catch (err) { console.error('Self-tests error', err); }
        console.table(results);
      }

      // boot
      runSelfTests();
      startRun();
      requestAnimationFrame(loop);
    })();
  </script>
</body>

</html>